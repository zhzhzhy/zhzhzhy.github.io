<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>cache的工作原理笔记</title>
      <link href="/en/2022/07/17/2022/csapp-cache/"/>
      <url>/en/2022/07/17/2022/csapp-cache/</url>
      
        <content type="html"><![CDATA[<p>高速缓存存储器 Cache<br>E = 1：直接映射高速缓存（direct-mapped cache）<br>E &gt; 1：组相联高速缓存（set associative cache）<br>E = C/B：全相联高速缓存（fully associative cache）</p><h1 id="存储器层次结构-memory-hierarchy"><a href="#存储器层次结构-memory-hierarchy" class="headerlink" title="存储器层次结构(memory hierarchy )"></a>存储器层次结构(memory hierarchy )</h1><p>缓存命中（cache hit）</p><p>缓存不命中（cache miss）</p><p>写的情况要复杂一些。假设我们要写一个已经缓存了的字 w（写命中 ，write hit）。在高速缓存更新了它的 w 的副本之后，怎么更新 w 在层次结构中紧接着低一层中的副本呢？</p><p>最简单的方法，称为直写（write-through），就是立即将 w 的高速缓存块写回到紧接着的低一层中。虽然简单，但是直写的缺点是每次都会引起总线流量。</p><p>另一种方法，称为写回（write-back），尽可能地推迟更新，只有当替换算法要驱逐这个更新过的块的时候，才把它写到紧接着的低一层中。由于局部性，写回能显著地减少总线流量，但是它的缺点是增加了复杂性。高速缓存必须为每个高速缓存行维护一个额外的修改位（dirty bit），表明这个高速缓存块是否被修改过。</p><p>另一个问题是如何处理写不命中。一种方法，称为写分配（write-allocate），加载相应的低一层中的块到高速缓存中，然后更新这个高速缓存块。写分配试图利用写的空间局部性，但是缺点是每次不命中都会导致一个块从低一层传送到高速缓存。另一种方法，称为非写分配（not-write-allocate），避开高速缓存，直接把这个字写到低一层（主存）中。直写是非写分配的，写回是写分配的。</p><p>存储器层次解耦股中较低层的缓存更可能使用写回，而不是直写。</p><p>Cost of Cache Misses</p><p>Huge difference between a hit and amiss</p><p>could be 100x, if just L1 and main memory<br>Would you believe 99% hits is twice as good as 97%?</p><p>Consider:<br>Cache hit time of 1 cycle<br>Miss penalty of 100 cycles<br>Average access time:<br>97% hits: 1 cycle + 0.03 _ 100 cycles = 4 cycles<br>99% hits: 1 cycle + 0.01 _ 100 cycles = 2 cycles<br>This is also why “miss rate” is used instead of “hit rate”</p><h2 id="write-through-amp-write-hit"><a href="#write-through-amp-write-hit" class="headerlink" title="write-through &amp; write-hit"></a>write-through &amp; write-hit</h2><p>What to do on a write-hit?<br>Write-through (write immediately to memory)<br>Write-back (defer write to memory until line is evicted)<br>Need a dirty bit to indicate if line is different from memory or not</p>]]></content>
      
      
      <categories>
          
          <category> cache </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cache </tag>
            
            <tag> 高速缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSAPP笔记--虚拟内存VM的地址翻译过程及页面置换算法</title>
      <link href="/en/2022/05/06/2022/csapp-TLB-cache/"/>
      <url>/en/2022/05/06/2022/csapp-TLB-cache/</url>
      
        <content type="html"><![CDATA[<!-- vim-markdown-toc GFM --><ul><li><a href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98vm-%E9%83%A8%E5%88%86">虚拟内存(VM) 部分</a><ul><li><a href="#tlbtranslation-lookaside-buffer">TLB(Translation lookaside buffer)</a><ul><li><a href="#%E5%B8%B8%E7%94%A8%E5%90%8D%E8%AF%8D">常用名词</a></li></ul></li><li><a href="#%E7%AB%AF%E5%88%B0%E7%AB%AF%E7%9A%84%E5%9C%B0%E5%9D%80%E7%BF%BB%E8%AF%91%E5%85%B7%E4%BD%93%E8%BF%87%E7%A8%8B">端到端的地址翻译(具体过程)</a><pre><code>  * [TLB](#tlb)  * [页表(Page Table)](#页表page-table)  * [高速缓存(Cache)](#高速缓存cache)</code></pre></li><li><a href="#%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95">页面置换算法</a><ul><li><a href="#%E6%9C%80%E4%BD%B3%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95opt">最佳置换算法(OPT)</a></li><li><a href="#%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BAfifo%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95">先进先出(FIFO)页面置换算法</a><ul><li><a href="#belady-anomaly">Belady Anomaly</a></li></ul></li><li><a href="#%E6%9C%80%E8%BF%91%E6%9C%80%E4%B9%85%E6%9C%AA%E4%BD%BF%E7%94%A8lru--least-recently-used%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95">最近最久未使用(LRU = Least Recently Used)置换算法</a></li><li><a href="#%E6%97%B6%E9%92%9Fclock%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95">时钟(CLOCK)置换算法</a></li></ul></li></ul></li></ul><!-- vim-markdown-toc --><h1 id="虚拟内存-VM-部分"><a href="#虚拟内存-VM-部分" class="headerlink" title="虚拟内存(VM) 部分"></a>虚拟内存(VM) 部分</h1><h2 id="TLB-Translation-lookaside-buffer"><a href="#TLB-Translation-lookaside-buffer" class="headerlink" title="TLB(Translation lookaside buffer)"></a>TLB(Translation lookaside buffer)</h2><blockquote><p>A translation lookaside buffer (TLB) is a memory cache that stores the recent translations of virtual memory to physical memory.</p></blockquote><p>TLB 是翻译后备缓冲器(translation lookaside buffer)的缩写，是 MMU 中关于 PTE 的小的缓存，目的是加速虚拟地址到物理地址的翻译</p><p>TLB 的一个例子</p><p><img src="/en/2022/05/06/2022/csapp-TLB-cache/4.png" alt="4.png"></p><center>虚拟地址中用以访问 TLB 的组成部分</center><p>所有的地址翻译步骤都是在芯片上的 MMU(memory management unit) 中执行的</p><p>地址翻译步骤：</p><ol><li>CPU 产生一个虚拟地址</li><li>MMU 从 TLB 中取出相应的 PTE(Page table entry)</li><li>MMU 将这个虚拟地址翻译成一个物理地址，并且将它发送到高速缓存/主存</li><li>高速缓存/主存将所请求的数据字返回给 CPU</li></ol><p><img src="/en/2022/05/06/2022/csapp-TLB-cache/5.png"></p><h3 id="常用名词"><a href="#常用名词" class="headerlink" title="常用名词"></a>常用名词</h3><table><thead><tr><th>缩写</th><th>描述</th></tr></thead><tbody><tr><td>$N = 2^n$</td><td>虚拟地址空间中的地址数量</td></tr><tr><td>$M = 2^m$</td><td>物理地址空间中的地址数量</td></tr><tr><td>$P = 2^p$</td><td>页的大小（字节）</td></tr></tbody></table><p>虚拟地址（VA）</p><table><thead><tr><th>缩写</th><th>英文全称</th><th>描述</th></tr></thead><tbody><tr><td>VPO</td><td>Virtual Page Offset</td><td>虚拟页面偏移量（字节）</td></tr><tr><td>VPN</td><td>Virtual Page Number</td><td>虚拟页号</td></tr><tr><td>TLBI</td><td>TLB Index</td><td>TLB 索引</td></tr><tr><td>TLBT</td><td>TLB Tag</td><td>TLB 标记</td></tr></tbody></table><p>物理地址（PA）</p><table><thead><tr><th>缩写</th><th>英文全称</th><th>描述</th></tr></thead><tbody><tr><td>PPO</td><td>Physical Page Offset</td><td>物理页面偏移量（字节）</td></tr><tr><td>PPN</td><td>Physical Page Number</td><td>物理页号</td></tr><tr><td>CO</td><td>Cache Offset</td><td>缓冲块内的字节偏移量</td></tr><tr><td>CI</td><td>Cache Index</td><td>高速缓存索引</td></tr><tr><td>CT</td><td>Cache Tag</td><td>高速缓存标记</td></tr></tbody></table><blockquote><p>Conceptually, a virtual memory is organized as an array of N contiguous byte-sized cells stored on disk.<br>Each byte has a unique virtual address that serves as an index into the array. The contents of the array on<br>disk are cached in main memory.</p></blockquote><p>从某种意义上来讲，虚拟内存也是一种缓存，是内容在主存的缓存。</p><p><img src="/en/2022/05/06/2022/csapp-TLB-cache/1.png" alt="1.png"></p><center>使用页表的地址翻译</center><h2 id="端到端的地址翻译-具体过程"><a href="#端到端的地址翻译-具体过程" class="headerlink" title="端到端的地址翻译(具体过程)"></a>端到端的地址翻译(具体过程)</h2><p>假设我们的系统是这样的：</p><ol><li>内存是按字节寻址的。</li><li>内存访问是针对 1 字节的字的（不是 4 字节的字）。</li><li>虚拟地址是 14 位长的（$n = 14$）。</li><li>物理地址是 12 位长的（$m = 12$）。</li><li>页面大小是 64 字节（$P = 64$）。</li><li>TLB 是四路组相联的，总共有 16 个条目。</li><li>L1 d-cache 是物理寻址、直接映射的，行大小为 4 字节，而总共有 16 个组。</li></ol><p><img src="/en/2022/05/06/2022/csapp-TLB-cache/7.png"></p><p>14 位虚拟地址(VA),12 位物理地址(PA)</p><p>每个页面是$2^6=64$Byte,所以虚拟地址和物理地址的低 6 位分别作为 VPO 和 PPO（这样偏移的话刚好能覆盖到地址）</p><p><img src="/en/2022/05/06/2022/csapp-TLB-cache/8.png"></p><h4 id="TLB"><a href="#TLB" class="headerlink" title="TLB"></a>TLB</h4><p>TLB 是利用 VPN 的位进行虚拟寻址的<br>TLB 是四路组相联的,TLBI 属于 VPN 的低两位($2^2=4$路),TLBT 属于 VPN 的高 6 位</p><h4 id="页表-Page-Table"><a href="#页表-Page-Table" class="headerlink" title="页表(Page Table)"></a>页表(Page Table)</h4><p>页表: 页表一共有$2^8 = 256$个 PTE(Page table entry),用索引它的 VPN 来标识每个 PTE</p><h4 id="高速缓存-Cache"><a href="#高速缓存-Cache" class="headerlink" title="高速缓存(Cache)"></a>高速缓存(Cache)</h4><p>每个块都是 4 Byte,低 2 位块偏移(Cache Offset)，高 6 位标记(Cache Tag)<br><img src="/en/2022/05/06/2022/csapp-TLB-cache/9.png"><br><img src="/en/2022/05/06/2022/csapp-TLB-cache/10.png"><br><img src="/en/2022/05/06/2022/csapp-TLB-cache/11.png"></p><p>当 CPU 执行一条读地址 0x03d4 处字节的加载指令,我们来手工模拟一下接下来发生的过程。</p><ol><li><p>MMU 从 0x03d4 取出 VPN(0x0F)，TLB 从 VPN 取出 TLBI(0x03)和 TLBT(0x3),TLBT 与 index 为 2 的块匹配,取出 PPN(0x0D)返回 MMU (TLB 命中)</p></li><li><p>MMU 将来自 PTE 的 PPN(0x0D)和来自虚拟地址的 VPO(0x14)连接起来,形成物理地址 0x354</p></li></ol><p><img src="/en/2022/05/06/2022/csapp-TLB-cache/12.png"></p><p>MMU 发送物理地址 0x354 给缓存，缓存从物理地址中抽取出缓存偏移 CO（0x0）、缓存组索引 CI（0x5）以及缓存标记 CT（0x0D）。</p><p>CI(0x5) 中的标记与 CT(0x0D) 相匹配,缓存命中,读出偏移量 CO 的字节 0x36，并返回给 MMU,MMU 把值传回 CPU</p><p>如果 TLB 不命中,PTE 无效，将会发生缺页中断(Page Fault),内核从磁盘调入合适的页面;另一种可能性是 PTE 是有效的，但是所需要的内存块在缓存中不命中</p><blockquote><p>缺页中断（英语：Page fault，又名硬错误、硬中断、分页错误、寻页缺失、缺页中断、页故障等）指的是当软件试图访问已映射在虚拟地址空间中，但是目前并未被加载在物理内存中的一个分页时，由中央处理器的内存管理单元所发出的中断。</p></blockquote><h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><h3 id="最佳置换算法-OPT"><a href="#最佳置换算法-OPT" class="headerlink" title="最佳置换算法(OPT)"></a>最佳置换算法(OPT)</h3><p>最佳(Optimal, OPT)置换算法所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面,这样可以保证获得最低的缺页率。</p><p>但由于人们目前无法预知进程在内存下的若千页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现。</p><p>(一个理论上的理想的算法)</p><p><img src="/en/2022/05/06/2022/csapp-TLB-cache/OPT.png" alt="OPT.png"></p><h3 id="先进先出-FIFO-页面置换算法"><a href="#先进先出-FIFO-页面置换算法" class="headerlink" title="先进先出(FIFO)页面置换算法"></a>先进先出(FIFO)页面置换算法</h3><p>队列的思想,把调入内存的页面根据先后次序链接成队列,设置一个指针总指向最早的页面</p><p><img src="/en/2022/05/06/2022/csapp-TLB-cache/FIFO.png" alt="FIFO.png"></p><h4 id="Belady-Anomaly"><a href="#Belady-Anomaly" class="headerlink" title="Belady Anomaly"></a>Belady Anomaly</h4><p>FIFO 算法还会产生当所分配的物理块数增大而页故障数不减反增的异常现象，这是由 Belady 于 1969 年发现，故称为 Belady 异常</p><p>只有 FIFO 算法可能出现 Belady 异常，而 LRU 和 OPT 算法永远不会出现 Belady 异常</p><p><a href="https://www.geeksforgeeks.org/beladys-anomaly-in-page-replacement-algorithms/">Belady’s Anomaly in Page Replacement Algorithms</a></p><p><img src="/en/2022/05/06/2022/csapp-TLB-cache/Belady.png" alt="Belady.png"></p><p>这样的反复换入换出会导致页面调用的抖动(Thrashing)</p><h3 id="最近最久未使用-LRU-Least-Recently-Used-置换算法"><a href="#最近最久未使用-LRU-Least-Recently-Used-置换算法" class="headerlink" title="最近最久未使用(LRU = Least Recently Used)置换算法"></a>最近最久未使用(LRU = Least Recently Used)置换算法</h3><p>选择最近最长时间未访问过的页面予以淘汰，它认为过去一段时间内未访问过的页面，在最近的将来可能也不会被访问。</p><p><img src="/en/2022/05/06/2022/csapp-TLB-cache/LRU.png" alt="LRU.png"></p><h3 id="时钟-CLOCK-置换算法"><a href="#时钟-CLOCK-置换算法" class="headerlink" title="时钟(CLOCK)置换算法"></a>时钟(CLOCK)置换算法</h3><p>简单的 CLOCK 算法是给每一帧关联一个附加位，称为使用位。</p><p>当某一页首次装入主存时，该帧的使用位设置为 1;当该页随后再被访问到时，它的使用位也被置为 1。</p><p>对于页替换算法，用于替换的候选帧集合看做一个循环缓冲区，并且有一个指针与之相关联。</p><p>当某一页被替换时，该指针被设置成指向缓冲区中的下一帧。当需要替换一页时，操作系统扫描缓冲区，以查找使用位被置为 0 的一帧。</p><p>每当遇到一个使用位为 1 的帧时，操作系统就将该位重新置为 0；如果在这个过程开始时，缓冲区中所有帧的使用位均为 0，则选择遇到的第一个帧替换；如果所有帧的使用位均为 1,则指针在缓冲区中完整地循环一周，把所有使用位都置为 0，并且停留在最初的位置上，替换该帧中的页。</p><p>由于该算法循环地检查各页面的情况，故称为 CLOCK 算法，又称为最近未用(Not Recently Used, NRU)算法。</p><hr><p>下一篇: 高速缓存(Cache)的工作原理</p>]]></content>
      
      
      <categories>
          
          <category> csapp </category>
          
          <category> cache </category>
          
          <category> TLB </category>
          
          <category> virtual memory </category>
          
      </categories>
      
      
        <tags>
            
            <tag> csapp </tag>
            
            <tag> cache </tag>
            
            <tag> TLB </tag>
            
            <tag> virtual memory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《理想国》柏拉图的哲学的三个比喻</title>
      <link href="/en/2022/03/26/2022/the-republic/"/>
      <url>/en/2022/03/26/2022/the-republic/</url>
      
        <content type="html"><![CDATA[<!-- vim-markdown-toc GFM --><ul><li><a href="#%E5%A4%AA%E9%98%B3%E6%AF%94%E5%96%BBanalogy-of-the-sun">太阳比喻(Analogy of the sun)</a></li><li><a href="#%E7%BA%BF%E6%AE%B5%E6%AF%94%E5%96%BBanalogy-of-the-divided-line">线段比喻(Analogy of the divided line)</a><ul><li><a href="#%E5%8F%AF%E8%A7%81%E4%B8%96%E7%95%8Cvisible-world">可见世界(visible world)</a></li><li><a href="#%E5%8F%AF%E7%9F%A5%E4%B8%96%E7%95%8Cintelligible-world">可知世界(intelligible world)</a></li></ul></li><li><a href="#%E6%B4%9E%E7%A9%B4%E6%AF%94%E5%96%BBallegory-of-the-cave">洞穴比喻(Allegory of the cave)</a><ul><li><a href="#%E6%B4%9E%E7%A9%B4%E7%94%9F%E6%B4%BB%E5%BD%B1%E5%AD%90%E4%B8%8E%E7%9C%9F%E5%AE%9E%E7%9A%84%E4%B8%96%E7%95%8C">洞穴生活——影子与真实的世界</a></li><li><a href="#%E6%B4%9E%E7%A9%B4%E6%AF%94%E5%96%BB%E7%9A%84%E6%84%8F%E4%B9%89">洞穴比喻的意义</a><ul><li><a href="#%E6%80%8E%E4%B9%88%E6%A0%B7%E6%89%8D%E8%83%BD%E4%BB%8E%E5%8F%AF%E8%A7%81%E4%B8%96%E7%95%8C%E5%88%B0%E5%8F%AF%E7%9F%A5%E4%B8%96%E7%95%8C%E5%91%A2">怎么样才能从可见世界到可知世界呢？</a></li></ul></li></ul></li><li><a href="#%E7%BB%93%E8%AE%BA">结论</a></li></ul><!-- vim-markdown-toc --><blockquote><p>Cogito,ergo sum.<br> <right>- René Descartes</right></p></blockquote><p>《理想国》(The Republic)全景式地展现了柏拉图一生所有重要的思想而成为他颇丰的著作中最具代表性的一部。<br>《苏菲的世界》也是一本很好的哲学入门读物，从《苏菲的世界》到柏拉图《理想国》的阅读，哲学对人的影响是潜移默化的,对人的心灵启发也是极为震撼的。<br>苏格拉底为了更好的阐述他所提出的相论，他分别提出了 <strong>太阳(Analogy of the sun)</strong> 、 <strong>线段(Analogy of the divided line)</strong> 以及 <strong>洞穴(Allegory of the cave)</strong> 三个比喻。</p><h2 id="太阳比喻-Analogy-of-the-sun"><a href="#太阳比喻-Analogy-of-the-sun" class="headerlink" title="太阳比喻(Analogy of the sun)"></a>太阳比喻(Analogy of the sun)</h2><blockquote><p>The analogy of the sun (or simile of the sun or metaphor of the sun) is found in the sixth book of The Republic (507b–509c).</p></blockquote><p>柏拉图认为理念是事物的本原，而最高的理念是善，善统摄所有的理念。善的定义却是很笼统的，每个人心目中都有他/她关于善的标准，善是一切美德和知识的来源，是许多人为之共同努力的目标。</p><p><img src="/en/2022/03/26/2022/the-republic/Analogy_of_the_sun.jpg"></p><blockquote><p>Socrates compares the “Good” with the sun. Plato might be using the image of the sun to help bring life to his arguments or to make the argument more clearly understood.</p></blockquote><p>太阳照耀万物，让世界有了光明，光和视觉让人们看到了这些可见的、美好的事物；善也是如此，善一直是人们所追求的，美好的东西让我们感受到善的存在，比如真理和知识，这些人类的智慧，因为这些善指引着人们追求好的事物，就像灯塔一样，也会感染其他人追求真理、知识和正义。</p><p>但我们不能说真理和知识就是善，它们只是善纯在的形式，这就好像视觉和光线可以让人看见世界万物，但是太阳才是这个至高无上存在的具体存在。</p><p>在现实生活中，我们一般不能肉眼直接看太阳，因为阳光很刺眼，时常让我们眼睛睁不开。真理也是如此，在现代，我们使用的所有数学模型，物理学的理论，所渴求的世界运行规律，都是迷人的令人激动的存在，但是我们去思考世界最基本运行规律时，就会变得异常困难和混沌，因为对真理的探索是困难而艰辛的。</p><blockquote><p>As goodness stands in the intelligible realm to intelligence and the things we know,<br>so the sun stands in the visible realm to sight and the things we see.<br> <right> — The Republic VI (508c): 171 </right></p></blockquote><h2 id="线段比喻-Analogy-of-the-divided-line"><a href="#线段比喻-Analogy-of-the-divided-line" class="headerlink" title="线段比喻(Analogy of the divided line)"></a>线段比喻(Analogy of the divided line)</h2><blockquote><p>The analogy of the divided line is presented by the Greek philosopher Plato in the Republic (509d–511e).<br></p></blockquote><blockquote><p>Socrates explains that the four resulting segments represent four separate ‘affections’ (παθήματα) of the psyche. The lower two sections are said to represent the visible while the higher two are said to represent the intelligible.</p></blockquote><p>柏拉图将我们的客观世界比作一个线段，这个线段分为不等的两段，一段代表 <strong>可见世界(visible world)</strong> ，另一段代表 <strong>可知世界(intelligible world)</strong></p><p>我们把两段按照同样的比例再分别分成两部分，然后我们再根据其清晰程度来比较第二次分成的部分，这样你就会看到可见世界的一部分表示 <strong>影像</strong> 。所谓影像我指的首先是 <strong>阴影</strong> ，其次是在水里或表面光滑的物体上反射出来的影子或其他类似的的东西。</p><p>柏拉图意图说明，意见的对象与知识的对象是相关联的，可见的世界只是另一个更为可靠的地方的镜中映像。日常生活中存在较为真实的性质（可见物体）以及较为不真实的性质（它们的影子和映像）。</p><p>较为不真实的性质(影子和映像)只是较为真实的性质（可见物体）的投影和映射。</p><p>于是这样一条令人费解的线段就形成了</p><p><img src="/en/2022/03/26/2022/the-republic/line.svg"><br>线喻（ A 至 C ）代表可见世界，（ CE ）代表可知（可理解）的世界</p><h3 id="可见世界-visible-world"><a href="#可见世界-visible-world" class="headerlink" title="可见世界(visible world)"></a>可见世界(visible world)</h3><blockquote><p>Thus AB represents shadows and reflections of physical things, and BC the physical things themselves. These correspond to two kinds of knowledge, the illusion (εἰκασία eikasia) of our ordinary, everyday experience, and belief (πίστις pistis) about discrete physical objects which cast their shadows.</p></blockquote><p>AB 代表 <strong>物理事物的影子和反射</strong> ，而 BC 代表 <strong>物理事物本身</strong> 。这个对应于两种知识： <strong>猜想(illusion)</strong> 和 <strong>信念(belief)</strong></p><h3 id="可知世界-intelligible-world"><a href="#可知世界-intelligible-world" class="headerlink" title="可知世界(intelligible world)"></a>可知世界(intelligible world)</h3><p><strong>可知世界</strong> 也被成为可理解的世界，对应 CE 段，被划分为与 AC 相同的百份比，从而给出了 CD 和 DE 细分</p><p>CD 段这一部分，人的灵魂被迫把可见世界中那些本身也有自己的影子的实际事物作为影像，从假设出发进行考察，从假设下降到结论，推导出事物的原理，物理、数学、化学、生物、几何、天文等自然科学就属于这一类，对应的是人的 <strong>理智</strong> (或者 <strong>思想（διάνοια）</strong> )。</p><p>另一个部分，DE 段中，人的灵魂则朝著另一方面前进，从假设上升到非假设的原则，并且不用在前一部分中所使用的影像，而只用“类型”，完全依据“类型”来取得系统的进展。），我们所追求的正义、法律啊，这一类需要用辩证法来思考，理解的是内在的原理，文学、哲学、语言学、社会科学等人文科学属于这一类， 对应的则是 <strong>理性（ νόησις ）</strong> 。</p><p><img src="/en/2022/03/26/2022/the-republic/divided-line.jpg"></p><table><thead><tr><th align="center">分割</th><th align="center">知识或意见的类型</th><th align="center">心理思考</th><th align="center">对象类型</th></tr></thead><tbody><tr><td align="center">DE</td><td align="center">理性 （ νόησις ）</td><td align="center">知识（理解）：不限于可理解（ νοητόν ）的都能够理解</td><td align="center">这些观念都是由善形式所赋予的真理（τὸαὐτὸἀγαθθν）</td></tr><tr><td align="center">CD</td><td align="center">思想（διάνοια）</td><td align="center">知识（思想）：认为知识不限于可理解的思想</td><td align="center">对于几何和数的想法</td></tr><tr><td align="center">BC</td><td align="center">信念（πίστις）</td><td align="center">观点（信念）：关于可见事物的本身</td><td align="center">可见事物的本身（ὁρατά）</td></tr><tr><td align="center">AB</td><td align="center">猜想（εikaκασία）</td><td align="center">观点（想象力）：关于一切的猜想</td><td align="center">可见事物的猜想（εἰκόνες）</td></tr></tbody></table><h2 id="洞穴比喻-Allegory-of-the-cave"><a href="#洞穴比喻-Allegory-of-the-cave" class="headerlink" title="洞穴比喻(Allegory of the cave)"></a>洞穴比喻(Allegory of the cave)</h2><blockquote><p>The Allegory of the Cave, or Plato’s Cave, is an allegory presented by the Greek philosopher Plato in his work Republic (514a–520a) to compare “the effect of education (παιδεία) and the lack of it on our nature”.</p></blockquote><p><img src="/en/2022/03/26/2022/the-republic/cave.jpg"></p><p>苏格拉底叙述了太阳比喻，以及线段比喻。<br>作为这一系列比喻的高潮和结尾，洞穴比喻为柏拉图哲学的基础，它清晰的阐释了柏拉图存在论和认识论的思想。</p><h3 id="洞穴生活——影子与真实的世界"><a href="#洞穴生活——影子与真实的世界" class="headerlink" title="洞穴生活——影子与真实的世界"></a>洞穴生活——影子与真实的世界</h3><p>苏格拉底描述了一个位于地下的洞穴住所，洞里有一条宽阔的道路通向地面。在这个山洞里居住着被囚禁于此的囚犯。他们的腿和脖子被链子固定，以致只能朝前看到洞穴的墙壁，而永远不能转身回头顾望。因此，他们永远看不到背后的洞穴出口，也根本不知道有这么一个出口。他们也不能看到自己和其他囚犯，他们唯一能看到的是他们所面对的墙壁。在他们身后远处是燃烧的篝火，囚犯看见火光照亮的墙壁，却看不见光源。他们只能看到墙上闪动的光影。</p><p>囚犯同火炬之间，有一堵不会遮挡光线的矮墙。顺着这堵墙壁，有人来回穿梭，搬运着不同的物品，包括一些用石头和木头做的人体和其他生物模型。这些物体高过那堵矮墙，但搬运者比墙低。其中的一些搬运者相互交谈，另一些则保持沉默。</p><p>由于囚犯面对洞穴墙壁，那些来回移动的物体在墙上投射的阴影，被囚犯当作是会移动的影子。当有人说话时，洞壁上的回声让囚犯以为是那些影子在说话。他们把这些影像当作生物，把所有发生的事情理解为这些生物的行为。墙上演绎的故事，对他们来说都是真相，绝对真实。他们从这些影子中钻研出一整套学问，并试图从它们的出场和动作中找出一系列的规律，并且由此预告将要发生的事情。</p><p>这些被锁住的人,应该会一直以为这些投在洞壁上的阴影就是他们的世界，那些声音就是这些影子所发出的。</p><p>如果在某个时候，被锁住的其中一个人可以松绑了,他可能会转身去看后面的世界，他就会看到那团火，看到路过的那些人，火光很刺眼，他会很不适应，可能很想回到原来的生活，那个被阴影和回声所构造的世界中,相比于过去熟悉的光影，他会认为现在看到的不真实，因为他相信只有在洞壁上能看见真相，他不会去相信一个善意解救者的说教。</p><p>如果强行将松绑的囚犯从洞穴中拖出,穿过那些陡峭的洞穴通道,来到阳光照耀的地面,他会更加不知所措。因为强烈的阳光会使他睁不开眼，刚开始时，他什么都看不见。慢慢地，他也许会适应眼前的新鲜事物，其过程也许是首先识别光影，然后是水中的倒影，最终才是人和事物本身。如果抬头看，他也许会先习惯夜晚的星空，然后才是白天的日光，最后才敢于直接目视太阳，从而感受太阳的独特之处。只有这时，他才能理解，是太阳造就了光影。有了这些经历和认识，他不会再愿意回到洞穴，他不再关心那里的光影学问，以及其它囚徒的赞誉。</p><p>如果来到地面上的人在经历这一切之后再回到地面，将这些经历讲述给一直都在地面下的人，洞穴里的人会嘲笑他,不理解他的讲述，一直不愿意离开洞穴。</p><h3 id="洞穴比喻的意义"><a href="#洞穴比喻的意义" class="headerlink" title="洞穴比喻的意义"></a>洞穴比喻的意义</h3><p>洞穴墙壁的那些阴影代表着 <strong>可见世界</strong> ，也就是普通人看到的世界，在自然科学领域就是数学模型(mathematical objects),洞穴的那团火就是可见世界的太阳，是善的存在，是人类对真理、正义、知识的追求,这些属于 <strong>可知世界</strong> 的内容，大部分人愿意去思考和表述一些具象化的事物，因为很清晰；但他们要去思考一些抽象的事物时，就会变得困难起来。</p><p>洞穴是人体感官所能及的世界的化身，它代表了人类的处境。走出洞穴并看见太阳的过程，则代表灵魂从可视的世界，提升到“理念的境界”，即只有精神才可领会的世界。柏拉图以此表达了他的理念论，即在他的理念世界里，存在着各种物质现象的原始理念。在这些纯粹的精神造物中，善的理念占据着最高的地位，它对应于洞穴比喻中的太阳。在对话中，苏格拉底确信，为了达成善良的理念，我们必须要接受外力的帮助，只有这样才能在私人和公众生活里理智地行事。</p><h4 id="怎么样才能从可见世界到可知世界呢？"><a href="#怎么样才能从可见世界到可知世界呢？" class="headerlink" title="怎么样才能从可见世界到可知世界呢？"></a>怎么样才能从可见世界到可知世界呢？</h4><p>怎么样才能从影子(可见世界)到光亮（可知世界）呢？那一定是转身，这个转身不一定是身体的转身，而是灵魂的转身,是你思考的重心从可见世界的事物，转向可知世界的内容。</p><p>怎么样才能走出洞穴呢？苏格拉底告诉我们，是 <strong>教育</strong> ，只有受教育的人，才能完成灵魂的转向，走出这个山洞，看到外面的世界。在苏格拉底的理解，这些受教育的人，正是哲学家，他说哲学家追求真正的知识,而普通人，只有意见（介于知识和无知之间）,所以只有哲学家才能真正领导洞穴里面的人更好的生活，通过哲学的思想去指导。</p><p>那么这些哲学家会带领所有的人走出洞穴吗？并不，最好的城邦依然在洞穴中，毕竟不是所有人都愿意走出洞穴，去迎接外面的世界。最好的城邦并没有脱离我们所认识的世界，绝大多数人都是普通人，能走出洞穴的是少数人，城邦在洞穴中只是迫不得已。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>现代哲学很多东西的源头都可以在理想国里面找得到。结果正义程序正义、可知论不可知论、形而上学、伦理学、认识论、社会学。哲学复杂但有其局限性，很多都存在争议性，很多思想又是相通的，这里能看到西方哲学思想的一些影子，一些核心思想对哲学的启发是关键性的，值得每个人去思考真正的“意义”究竟是什么。</p>]]></content>
      
      
      <categories>
          
          <category> Socrates </category>
          
          <category> philosophy </category>
          
          <category> Plato </category>
          
          <category> 理想国 </category>
          
          <category> 读书笔记 </category>
          
          <category> 哲学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Socrates </tag>
            
            <tag> philosophy </tag>
            
            <tag> Plato </tag>
            
            <tag> 理想国 </tag>
            
            <tag> 读书笔记 </tag>
            
            <tag> 哲学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式“无网络”传感器|由Apple AirTag对未来物联网的展望</title>
      <link href="/en/2022/03/23/2022/find_my_network/"/>
      <url>/en/2022/03/23/2022/find_my_network/</url>
      
        <content type="html"><![CDATA[<!-- vim-markdown-toc GFM --><ul><li><a href="#%E4%BB%8Eesp8266%E8%87%AA%E7%BB%84%E7%BB%87%E7%BD%91%E7%BB%9C%E8%B0%88%E8%B5%B7-esp-wifi-mesh">从ESP8266自组织网络谈起 ESP-WIFI-MESH</a></li><li><a href="#%E5%88%86%E5%B8%83%E5%BC%8F%E5%8E%BB%E4%B8%AD%E5%BF%83%E5%8C%96%E5%85%B1%E8%AF%86">分布式、去中心化、共识</a></li><li><a href="#apple-find-my%E4%B8%80%E7%A7%8D%E6%9B%B4%E5%B9%BF%E6%B3%9B%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E4%BD%8D%E7%BD%AE%E7%BD%91%E7%BB%9C">Apple Find my:一种更广泛的分布式位置网络</a></li><li><a href="#apple%E7%9A%84%E6%9F%A5%E6%89%BEfind-my%E7%BD%91%E7%BB%9C%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">Apple的查找(Find My)网络工作原理</a><ul><li><a href="#%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E5%92%8C%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86">对称加密和非对称加密</a></li><li><a href="#%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95elliptic-curve-cryptography">椭圆曲线加密算法(Elliptic Curve Cryptography)</a><ul><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF">什么是椭圆曲线?</a></li><li><a href="#%E9%98%BF%E8%B4%9D%E5%B0%94%E7%BE%A4abelian-group">阿贝尔群(abelian group)</a></li><li><a href="#%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E4%B8%AD%E7%9A%84%E9%98%BF%E8%B4%9D%E5%B0%94%E7%BE%A4">椭圆曲线中的阿贝尔群</a></li><li><a href="#%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E5%8A%A0%E8%A7%A3%E5%AF%86%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86">椭圆曲线加解密算法原理</a></li></ul></li><li><a href="#find-my-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">Find My 工作原理</a></li></ul></li><li><a href="#%E4%BD%BF%E7%94%A8apple-find-my%E5%9C%A8%E6%97%A0%E7%BD%91%E7%BB%9C%E7%8E%AF%E5%A2%83%E5%8F%91%E9%80%81%E4%BB%BB%E6%84%8F%E6%96%87%E6%9C%AC%E6%95%B0%E6%8D%AE">使用Apple Find My在“无网络”环境发送任意文本数据</a><ul><li><a href="#%E5%A4%A7%E6%A6%82%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%91%A2">大概是怎么实现的呢?</a><ul><li><a href="#%E7%BC%96%E7%A0%81%E5%8F%91%E9%80%81">编码发送</a></li><li><a href="#%E6%8E%A5%E6%94%B6%E8%A7%A3%E7%A0%81">接收解码</a></li><li><a href="#%E6%80%A7%E8%83%BD">性能</a></li></ul></li></ul></li><li><a href="#%E5%AE%9E%E9%99%85%E7%9A%84%E5%BA%94%E7%94%A8%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E9%98%B2%E8%8C%83">实际的应用与网络安全防范</a></li><li><a href="#%E6%9C%80%E6%96%B0%E7%9A%84%E9%A1%B9%E7%9B%AE%E8%BF%9B%E5%B1%95">最新的项目进展</a></li><li><a href="#%E6%9C%AA%E6%9D%A5%E7%9A%84%E7%89%A9%E8%81%94%E7%BD%91%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C%E5%8F%91%E5%B1%95%E6%96%B9%E5%90%91">未来的物联网传感器网络发展方向</a></li><li><a href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE%E5%8F%8A%E8%B5%84%E6%96%99references">参考文献及资料(References)</a></li></ul><!-- vim-markdown-toc --><p>无论从世界局势还是技术革新等层面，当今世界正在经历百年未有之大变局，移动互联的底层技术、算法，数学世界微妙的定理，可知世界那些看不见的事物，却往往成为现代社会不可替代的数字化和信息化互联网的基石。</p><h2 id="从ESP8266自组织网络谈起-ESP-WIFI-MESH"><a href="#从ESP8266自组织网络谈起-ESP-WIFI-MESH" class="headerlink" title="从ESP8266自组织网络谈起 ESP-WIFI-MESH"></a>从ESP8266自组织网络谈起 ESP-WIFI-MESH</h2><blockquote><p>ESP-WIFI-MESH 是一种无线通信网络，采用树状拓扑结构，其节点具有乐鑫 SoC 的 AP-STA 特性。ESP-WIFI-MESH 能够提供一个易于部署、自动组网并自我修复的网络。它无需部署 Wi-Fi 基础设施，就能在更大范围内部署节点，基于这种网络拓扑结构，它最多可以扩展到 1000 个节点。这样一来，ESP-WIFI-MESH 也可用于在家庭部署中覆盖 Wi-Fi 信号无法到达的盲点。</p></blockquote><p><img src="/en/2022/03/23/2022/find_my_network/ESP-MESH-Network-ESP32-ESP8266i.webp"></p><p>esp8266，wifi模块，玩嵌入式的应该都不陌生，一个esp8266作为一个node，可以部署一个自组织的网络，此网络少数node掉线不会影响整个网络的通信，设备能够根据节点信号的强度值自动连接信号强的节点，在网络故障时仍保证网络的稳定性，这也是ESP-WIFI-MESH的自我修复特性。</p><h2 id="分布式、去中心化、共识"><a href="#分布式、去中心化、共识" class="headerlink" title="分布式、去中心化、共识"></a>分布式、去中心化、共识</h2><p>在计算机技术领域，去中心化结构使用分布式核算和存储，不存在中心化的节点，任意节点的权利和义务都是均等的，系统中的数据块由整个系统中具有维护功能的节点来共同维护，任一节点停止工作都不会影响系统整体的运作。<br>去中心化是分布式网络结构中的一种，所有的去中心化都是采用分布式网络结构的，而分布式网络结构可能是“中心化”也可能是“去中心化”的</p><p><img src="/en/2022/03/23/2022/find_my_network/1.png" alt="1.png"></p><blockquote><p>去中心化和共识是两个不同的概念，两者结合才是真正意义上的“去中心化”，去中心化有了共识才具备了完全的可信度，否则只是狭义概念的数据共享，没人知道这些共享的数据是否真实，或者被集体认可，仅仅只是拥有这些信息；共识有了去中心化，就具备了安全性，系统很难被攻破，信息也难被篡改；再加上特殊的数据结构，而这一切的实现就是区块链。</p></blockquote><h2 id="Apple-Find-my-一种更广泛的分布式位置网络"><a href="#Apple-Find-my-一种更广泛的分布式位置网络" class="headerlink" title="Apple Find my:一种更广泛的分布式位置网络"></a>Apple Find my:一种更广泛的分布式位置网络</h2><blockquote><p>Overnight, Apple has turned its hundreds-of­million-device ecosystem into the world’s largest crowd­sourced location tracking network called offine ﬁnding (OF). OF leverages online ﬁnder devices to detect the presence of missing onine devices using Bluetooth and report an approximate location back to the owner via the Internet. While OF is not the ﬁrst system of its kind, it is the ﬁrst to commit to strong privacy goals. In particular, OF aims to ensure ﬁnder anonymity, un­trackability of owner devices, and conﬁdentiality of lo­cation reports.</p></blockquote><p>熟悉苹果设备和苹果生态的朋友，应该对“查找”这一功能并不陌生，只要是使用同一 Apple ID 登录的设备，当你不慎将其丢失或遗忘位置时，即可使用“查找”对其定位或发出声响，特殊情况下还可以选择抹除资料避免信息泄露。</p><p>得益于全世界苹果设备的保有量(全球活跃约18亿台，截至2022年1月28日)，以及全球的广泛分布¹， 苹果的Find My已经作为icloud基础设施使用，利用庞大的用户量、广泛分布的苹果设备，用户可以获得比Android等其他移动设备更好的设备查找和定位体验。</p><p>AirTag是苹果公司于2021年4月21日凌晨在2021苹果春季新品发布会上推出的一款蓝牙跟踪设备。</p><p>Airtag的离线查找恰好利用了Find My网络，可以在世界任意角落找到你丢失的Airtag(理论上)</p><h2 id="Apple的查找-Find-My-网络工作原理"><a href="#Apple的查找-Find-My-网络工作原理" class="headerlink" title="Apple的查找(Find My)网络工作原理"></a>Apple的查找(Find My)网络工作原理</h2><p>德国达姆施塔特的公立大学(Technical University of Darmstadt)的移动网络安全实验室(Secure Mobile Networking Lab)在2019年6月开始对苹果的Find My 进行逆向工程和安全分析，大部分研究结果在2021年3月公开，期间发现的最严重的一个漏洞<a href="https://support.apple.com/en-us/HT211849">CVE-2020-9986</a> (允许恶意软件访问位置数据)已经被苹果修复</p><p>在发布论文的时候，他们开源了一个叫做OpenHaystack的项目，这个开源项目可以让你创建自己的配件，被苹果的Find My网络跟踪</p><p><img src="/en/2022/03/23/2022/find_my_network/OpenHaystack-Screenshot.png"></p><center>openhaystack mac端</center><br><p><img src="/en/2022/03/23/2022/find_my_network/8.jpg"></p><p>苹果的“查找”功能利用蓝牙广播，公钥加密技术以及中心加密的位置报告数据库，基于椭圆曲线加密算法(Elliptic Curve Cryptography)的安全性， 私钥在用户手中，苹果声称位置报告、查找设备标志 被加密和隐藏了，并且蓝牙广播无法直接用于跟踪用户，安全性和隐私性没有任何问题。</p><p><strong>简单介绍一下椭圆曲线加密算法</strong></p><h3 id="对称加密和非对称加密"><a href="#对称加密和非对称加密" class="headerlink" title="对称加密和非对称加密"></a>对称加密和非对称加密</h3><p>对称加密(Symmetric-key algorithm)指<strong>加密和解密使用相同密钥</strong>的加密算法。常见的对称加密算法有DES、3DES、AES</p><p>非对称加密(public-key cryptography OR asymmetric cryptography)是<strong>加密和解密使用不同密钥</strong>，使用公钥/私钥对中的公钥来加密明文，然后使用对应的私钥来解密密文的过程。RSA、Elgamal、背包算法、Rabin、Diffie-Hellman、ECC属于非对此加密，使用最广泛的是RSA算法</p><h3 id="椭圆曲线加密算法-Elliptic-Curve-Cryptography"><a href="#椭圆曲线加密算法-Elliptic-Curve-Cryptography" class="headerlink" title="椭圆曲线加密算法(Elliptic Curve Cryptography)"></a>椭圆曲线加密算法(Elliptic Curve Cryptography)</h3><p>椭圆曲线加密算法，简称ECC，是基于椭圆曲线数学理论实现的一种非对称加密算法。相比RSA，ECC优势是可以使用更短的密钥，来实现与RSA相当或更高的安全，RSA加密算法也是一种非对称加密算法，在公开密钥加密和电子商业中RSA被广泛使用。RSA算法是当前最流行也是最明了的公钥密码学系统。它的安全性基于因式分解的缓慢和乘法的快速的事实上。</p><h4 id="什么是椭圆曲线"><a href="#什么是椭圆曲线" class="headerlink" title="什么是椭圆曲线?"></a>什么是椭圆曲线?</h4><p>Wolfram MathWorld（线上数学百科全书，<a href="http://mathworld.wolfram.com)/">http://mathworld.wolfram.com）</a> 给出了非常精准的定义：<br>一条椭圆曲线就是一组被 $y^2 = x^3 + ax + b$定义的且满足 $4a^3 + 27b^2 ≠ 0$ 的点集。</p><p>$4a^3 + 27b^2 ≠ 0$ 这个限定条件是为了保证曲线不包含奇点（在数学中是指曲线上任意一点都存在切线）。</p><p><img src="/en/2022/03/23/2022/find_my_network/3.png"></p><h4 id="阿贝尔群-abelian-group"><a href="#阿贝尔群-abelian-group" class="headerlink" title="阿贝尔群(abelian group)"></a>阿贝尔群(abelian group)</h4><p>阿贝尔群的概念是抽象代数的基本概念之一，是一种代数结构，由一个集合以及一个二元运算所组成。<br>如果一个集合或者运算是群的话，就必须满足以下条件（+ 表示二元运算）：</p><ol><li>封闭性（closure），如果a和b被包含于群，那么a+b也一定是群的元素；</li><li>结合律(associativity)；</li><li>存在一个单位元（identity element）0，0与任意元素运算不改变其值的元素，即 $a+0 = 0+a = a$；</li><li>每个元素都存在一个逆元(inverse)；</li><li>交换律(commutativity)，即 $a+b = b+a$；</li></ol><h4 id="椭圆曲线中的阿贝尔群"><a href="#椭圆曲线中的阿贝尔群" class="headerlink" title="椭圆曲线中的阿贝尔群"></a>椭圆曲线中的阿贝尔群</h4><p>我们可以在椭圆曲线上定义一个群：</p><ol><li>群中的元素就是椭圆曲线上的点；</li><li>单位元就是无穷处的点0；</li><li>相反数P，是关于X轴对称的另一边的点；</li><li>二元运算规则定义如下：取一条直线上的三点（这条直线和椭圆曲线相交的三点），P, Q, R（皆非零），他们的总和等于0，$P+Q+R=0$。</li></ol><p>可以证明，椭圆曲线符合阿贝尔群。</p><p>因为在安全性、加解密性能、网络消耗方面有较大优势，ECC加密算法大有取代RSA成为下一代主流加密算法的趋势。如今ECC应用范围很广，在TLS、区块链（比特币、以太坊等等）、SM2国密算法、证书、银行政府机构等许多方面都有大量应用。</p><p>椭圆曲线算法涉及阿贝尔群、有限群等群论知识，密钥交换涉及伽罗瓦域,具体的细节比较复杂，这里就不过多展开了，详细可以参考这篇论文：<a href="https://iacr.org/archive/pkc2003/25670211/25670211.pdf">ECIES</a></p><h4 id="椭圆曲线加解密算法原理"><a href="#椭圆曲线加解密算法原理" class="headerlink" title="椭圆曲线加解密算法原理"></a>椭圆曲线加解密算法原理</h4><p>设私钥、公钥分别为d、Q，即$Q = dG$，其中G为基点，椭圆曲线上的已知G和dG，求d是非常困难的，也就是说已知公钥和基点，想要算出私钥是非常困难的。<br>公钥加密：选择随机数r，将消息M生成密文C，该密文是一个点对，$C = {rG, M+rQ}$，其中Q为公钥。<br>私钥解密：<br>$M + rQ - d(rG) = M + r(dG) - d(rG) = M$，其中d、Q分别为私钥、公钥。</p><h3 id="Find-My-工作原理"><a href="#Find-My-工作原理" class="headerlink" title="Find My 工作原理"></a>Find My 工作原理</h3><ol><li> AirTag跟苹果设备配对的时候，保留在AirTag上的公钥和用于生成滚动公钥的共享密钥一起生成椭圆曲线密钥对</li><li>每2秒，AirTag用上一步的共享密钥(这个每15分钟会更新一次)，发送一个以公钥为内容的低功耗蓝牙广播</li><li>附近的iphone，macbook之类的可是识别Find My广播的设备，对搜索他当前的位置，然后用广播的公钥加密位置信息，然后上传这个加密的位置报告</li><li>在搜索设备的时候，这个设备的配对多有着，会生成AirTag这几天用的滚动公钥列表，并且查询苹果服务来获得他的SHA256哈希值，苹果的后台就会返回所请求密钥的加密位置报告<br>那么设备的所有者就可以解密位置报告并且显示大致的位置</li></ol><p><img src="/en/2022/03/23/2022/find_my_network/2.png"></p><p>这种做法有一些安全上的特性：</p><ul><li>滚动公钥可以保护附近的设备</li><li>苹果官方无法访问用户位置</li></ul><p>苹果是不知道哪些公钥是属于你的AirTag设备的，因此他也不知道哪些位置报告是你的，所以你去请求特定密钥的位置报告，是不需要授权的，知道密钥就可以直接要。同时位置报告通过了加密，所以就只能用存在配对的所有者设备上的私钥要解密。</p><blockquote><p>OF(offline finding) employs elliptic curve cryptography (ECC) for en­crypting location reports. ECC is a public-key encryp­tion scheme that uses operations on elliptic curve (EC) over ﬁnite ﬁelds. An EC is a curve over a ﬁnite ﬁeld that contains a known generator (or base point) G. A private key in ECC is a random number in the ﬁnite ﬁeld of the used curve. The public key is the result of the point multiplication of the generator G with the pri­vate key. The result is an X–Y coordinate on the curve. The NIST P-224 curve [39], which is used by OF [6], provides a security level of 112 bit.</p></blockquote><h2 id="使用Apple-Find-My在“无网络”环境发送任意文本数据"><a href="#使用Apple-Find-My在“无网络”环境发送任意文本数据" class="headerlink" title="使用Apple Find My在“无网络”环境发送任意文本数据"></a>使用Apple Find My在“无网络”环境发送任意文本数据</h2><p>原文地址</p><p><a href="https://positive.security/blog/send-my">Send My: Arbitrary data transmission via Apple’s Find My network</a></p><blockquote><p>With the recent release of Apple’s AirTags, I was curious whether Find My’s Offline Finding network could be (ab)used to upload arbitrary data to the Internet, from devices that are not connected to WiFi or mobile internet. The data would be broadcasted via Bluetooth Low Energy and picked up by nearby Apple devices, that, once they are connected to the Internet, forward the data to Apple servers where it could later be retrieved from. Such a technique could be employed by small sensors in uncontrolled environments to avoid the cost and power-consumption of mobile internet. It could also be interesting for exfiltrating data from Faraday-shielded sites that are occasionally visited by iPhone users.</p></blockquote><p>作者在<a href="https://github.com/seemoo-lab/openhaystack">Openhaystack</a>的基础上进行二次开发</p><p>通过给附近的苹果设备发送Find My蓝牙广播，可以让没有互联网连接的设备上传数据</p><p>用ESP32做了一个上传数据的网关，并且还写了一个macOS的程序来接收数据，ESP32固件以及macOS程序在github上开源</p><p><img src="/en/2022/03/23/2022/find_my_network/4.png"></p><h3 id="大概是怎么实现的呢"><a href="#大概是怎么实现的呢" class="headerlink" title="大概是怎么实现的呢?"></a>大概是怎么实现的呢?</h3><h4 id="编码发送"><a href="#编码发送" class="headerlink" title="编码发送"></a>编码发送</h4><blockquote><p>To send a full message, the program simply loops over its bits and sends out one advertisement per bit with the public key that encodes its index and value.</p></blockquote><ol><li>假设有一个message需要发送</li><li>每次取出这个message的第index位比特值value</li><li>用index和value，以及消息ID和补充的0位，构成一个公钥</li><li>用蓝牙将这个公钥广播出去</li><li>一直循环直到这个message的所有比特位都全部发送完成就好了</li></ol><p><img src="/en/2022/03/23/2022/find_my_network/5.png"></p><h4 id="接收解码"><a href="#接收解码" class="headerlink" title="接收解码"></a>接收解码</h4><blockquote><p>When fetching data, the receiving application will generate the same 28-byte arrays (two per bit, for the possible bit values 0 and 1) and query the Apple service with the SHA256 hashes of those “public keys”. Only one of the two key ids should have location reports attached, which can then be interpreted (e.g. bit at index 0 equals 1).</p></blockquote><ol><li>假设我们要接受一个message，我们需要确定这个message每个比特位是0还是1</li><li>按照index顺序，生成跟上一步一样的公钥，但是我们不知道最后的比特位是0还是1，这是我们要最终接收的目标数据，因此最后的比特位，按照0生成一个公钥，按照1生成一个公钥</li><li>用这个公钥的SHA256值去苹果的服务上查，看一下哪些公钥是能查到位置报告的</li><li>有位置报告的公钥，就是有效的，没有位置报告的公钥就是无效</li><li>将有效的公钥按照index排列最后的比特位，即可得到数据</li></ol><p><img src="/en/2022/03/23/2022/find_my_network/6.png"></p><h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><blockquote><p>The sending rate on the microcontroller is currently ~3 bytes/second<br><br> the receiving rate was limited by slow Mac hardware. Retrieving 16 bytes within one request takes ~5 seconds<br><br> The latency is usually between 1 and 60 minutes depending on how many devices are around and other random factors.</p></blockquote><p>发送速率大概3字节/秒，接收16字节大概需要5秒，跟人说话速率差不多，不过如果用于环境传感器(温湿度气压)数据的话，这个速率可以接受</p><p>延迟大概1~60分钟不等，取决于周围苹果设备的数量。</p><p><img src="/en/2022/03/23/2022/find_my_network/7.png"></p><h2 id="实际的应用与网络安全防范"><a href="#实际的应用与网络安全防范" class="headerlink" title="实际的应用与网络安全防范"></a>实际的应用与网络安全防范</h2><p>技术永远是把双刃剑，这个在未来信息化和数字化的时代会越来越凸显。</p><p>最大的应用场景就是没有网络的物联网设备LOT,没有手机SIM卡,没有蜂窝数据，没有Wifi的低功耗嵌入式设备</p><p>物理隔离的环境，法拉第笼屏蔽电磁的环境，某些保密要害部位，这些地方就算安全也可能泄密,因为访客的苹果设备可能会将信息泄漏出去，因为这些地方就算没有互联网或者手机信号，也有可能被访客的苹果设备缓存在设备中，直到这些设备再次连接互联网后，缓存的信息就会被发送出去。</p><p>这也是保密要害部位和一些物理隔离的重要涉密场所不让带手机进入的重要原因，某些重点保密单位不让使用苹果设备的原因也是如此，因为这些技术目前没有特定的解决方案，只能防范，毕竟国家安全至上，保守国家秘密是每个公民的基本义务。</p><blockquote><p>While I was mostly just curious about whether it would be possible, I would imagine the most common use case to be uploading sensor readings or any data from IoT devices without a broadband modem, SIM card, data plan or Wifi connectivity. With Amazon running a similar network called Sidewalk that uses Echo devices there might very well be demand for it. Since the Finding devices cache received broadcasts until they have an Internet connection, the sensors can even send out data from areas without mobile coverage as long as people pass the area.<br><br> In the world of high-security networks, where combining lasers and scanners seems to be a noteworthy technique to bridge the airgap, the visitor’s Apple devices might also become feasible intermediaries to exfiltrate data from certain airgapped systems or Faraday caged rooms.<br><br>It also seems like the Offline Finding protocol could be used to deplete nearby iPhone’s mobile data plans. With the number of location reports from a Finder device being limited (to 255 reports/submission due to a 1 byte count value) and each report being over 100 byte, broadcasting many unique public keys should result in an amplified amount of mobile traffic sent by the phone. While I haven’t noticed any rate limiting on the number of location reports sent out, I also haven’t tested how much data this would consume.</p></blockquote><h2 id="最新的项目进展"><a href="#最新的项目进展" class="headerlink" title="最新的项目进展"></a>最新的项目进展</h2><blockquote><p>This project uses OpenHaystack to upload sensor data from a device without internet connection by (ab)using Apple’s Find My network. The data is broadcasted via Bluetooth Low Energy and forwarded by nearby Apple devices.<br><br>The application is based on the Send My project and runs on the real-time operating system Zephyr. Because this firmware is based on Zephyr, you can create your own sensor boards with one of the many Bluetooth Low Energy devices that Zephyr supports.<br><br>After flashing the firmware to your device, it sends out Bluetooth Low Energy advertisements with sensor data that will be visible in Send My’s DataFetcher application in macOS.</p></blockquote><p><a href="https://github.com/koenvervloesem/send-my-sensor">https://github.com/koenvervloesem/send-my-sensor</a></p><p>这个开源项目实现的是Zephyr设备发送“无网络”传感器数据，目前还在开发阶段，基本固件已经完成。</p><p>截至2022-2-13，已经实现了一个低功耗嵌入式设备传输气压传感器的数据了，通信协议是$i^2c$,源码修改之后就能适应各种传感器了</p><h2 id="未来的物联网传感器网络发展方向"><a href="#未来的物联网传感器网络发展方向" class="headerlink" title="未来的物联网传感器网络发展方向"></a>未来的物联网传感器网络发展方向</h2><p>如上文所示，如果要自主建立这样一个分布式传感器网络，基础设施是很重要的，如果能有一个像苹果Find My的软硬件生态的话，当然更好，通过物联网从网络基础设施的接入，可以大大降低传感器网络的成本，实现大范围部署传感器网络.</p><p>展望一下未来，超低功耗MESH工业物联网，户外接入设备无需高功耗的通信协议，通过蓝牙BLE接入互联网的应用层，这层物联网直接不依赖于经典的OSI 参考7层模型，或者TCP/IP 5层协议栈，通过这些分布式的AC(acess point)接入互联网,实现万物互联。</p><h2 id="参考文献及资料-References"><a href="#参考文献及资料-References" class="headerlink" title="参考文献及资料(References)"></a>参考文献及资料(References)</h2><p>[1] Alexander Heinrich, Milan Stute, Tim Kornhuber, Matthias Hollick. <strong>Who Can <em>Find My</em> Devices? Security and Privacy of Apple’s Crowd-Sourced Bluetooth Location Tracking System.</strong> <em>Proceedings on Privacy Enhancing Technologies (PoPETs)</em>, 2021. <a href="https://doi.org/10.2478/popets-2021-0045">doi:10.2478/popets-2021-0045</a> <a href="https://www.petsymposium.org/2021/files/papers/issue3/popets-2021-0045.pdf">📄 Paper</a> <a href="https://arxiv.org/abs/2103.02282">📄 Preprint</a>.</p><p>[2] Apple Inc. <strong>Find My Network Accessory Specification – Developer Preview – Release R3.</strong> 2020. <a href="https://developer.apple.com/find-my/">📄 Download</a>.</p><p>[3] 椭圆曲线加密算法原理解析（ECC）<a href="https://segmentfault.com/a/1190000019172260">https://segmentfault.com/a/1190000019172260</a></p><p>[4] ESP-WIFI-MESH 概览| 乐鑫科技 <a href="https://www.espressif.com/zh-hans/products/sdks/esp-wifi-mesh/overview">https://www.espressif.com/zh-hans/products/sdks/esp-wifi-mesh/overview</a></p><p>[5] OpenHaystack project <a href="https://github.com/seemoo-lab/openhaystack">https://github.com/seemoo-lab/openhaystack</a></p><p>[6]  FABIAN BRÄUNLEIN , Positive Security. <strong>send my: arbitrary data transmission via apple’s find my network.</strong> <a href="https://positive.security/blog/send-my">https://positive.security/blog/send-my</a></p>]]></content>
      
      
      <categories>
          
          <category> Apple </category>
          
          <category> Bluetooth </category>
          
          <category> location privacy </category>
          
          <category> reverse engineering </category>
          
          <category> trackings tags </category>
          
          <category> user identification </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AirTag </tag>
            
            <tag> Find My Network </tag>
            
            <tag> openhaystack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Openwrt完整备份以及exroot挂载/overlay的思考</title>
      <link href="/en/2022/03/20/2022/openwrt-bakcup-step/"/>
      <url>/en/2022/03/20/2022/openwrt-bakcup-step/</url>
      
        <content type="html"><![CDATA[<!-- vim-markdown-toc GFM --><ul><li><a href="#openwrt">openwrt</a></li><li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AE%8C%E6%95%B4%E5%A4%87%E4%BB%BDopenwrt">为什么要完整备份openwrt?</a><ul><li><a href="#overlay-%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%E5%91%A2"><code>/overlay</code> 是什么意思呢？</a></li></ul></li><li><a href="#%E7%BD%91%E4%B8%8A%E7%9A%84%E5%A4%87%E4%BB%BD%E6%96%B9%E6%B3%95%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98">网上的备份方法遇到的问题</a><ul><li><a href="#mtdmemory-technology-device%E5%A4%87%E4%BB%BD">MTD(Memory Technology Device)备份</a></li><li><a href="#%E4%BB%85%E5%AF%B9-overlay-%E6%89%93%E5%8C%85%E5%A4%87%E4%BB%BD">仅对 /overlay 打包备份</a></li></ul></li><li><a href="#%E7%A8%B3%E5%A6%A5%E7%9A%84%E5%8A%9E%E6%B3%95%E5%8F%AA%E4%BF%9D%E7%95%99%E8%AE%BE%E7%BD%AE%E5%8D%87%E7%BA%A7%E5%A4%87%E4%BB%BD%E8%BD%AF%E4%BB%B6%E5%8C%85%E5%88%97%E8%A1%A8opkg%E6%81%A2%E5%A4%8D%E8%BD%AF%E4%BB%B6%E5%8C%85">稳妥的办法:只保留设置升级，备份软件包列表，opkg恢复软件包</a><ul><li><a href="#what-to-do">What to do:</a></li></ul></li></ul><!-- vim-markdown-toc --><h2 id="openwrt"><a href="#openwrt" class="headerlink" title="openwrt"></a>openwrt</h2><blockquote><p>OpenWrt项目是一个针对嵌入式设备的Linux操作系统。OpenWrt不是一个单一且不可更改的固件，而是提供了具有软件包管理功能的完全可写的文件系统。这使您可以从供应商提供的应用范围和配置中解脱出来，并且让您通过使用适配任何应用的软件包来定制设备。对于开发人员来说，OpenWrt是一个无需围绕它构建完整固件就能开发应用程序的框架; 对于普通用户来说，这意味着拥有了完全定制的能力，能以意想不到的方式使用该设备。</p></blockquote><p>项目地址</p><p><a href="https://openwrt.org/">openwrt.org</a></p><h2 id="为什么要完整备份openwrt"><a href="#为什么要完整备份openwrt" class="headerlink" title="为什么要完整备份openwrt?"></a>为什么要完整备份openwrt?</h2><p>为了无缝升级！为了能在升级的同时不丢失配置文件及软件包</p><p><strong>总所周知，openwrt的文件系统的精华思想是overlay</strong></p><h3 id="overlay-是什么意思呢？"><a href="#overlay-是什么意思呢？" class="headerlink" title="/overlay 是什么意思呢？"></a><code>/overlay</code> 是什么意思呢？</h3><blockquote><p>OpenWRT 一般使用的文件系统是 SquashFS ，这个文件系统的特点就是：只读。<br>那，一个只读的文件系统，是怎么做到保存设置和安装软件的呢？<br>这里就是使用一个 /overlay 的分区，overlay顾名思义就是覆盖在上面一层的意思。<br>虽然原来的文件不能修改，但我们把修改的部分放在 overlay 分区上，然后映射到原来的位置，读取的时候就可以读到我们修改过的文件了。<br>但为什么要用这么复杂的方法呢？ OpenWRT 当然也可以使用 EXT4 文件系统，但使用 SquashFS + overlay 的方式有一定的优点。<br>首先 SquashFS 是经过压缩的，在路由器这种小型 ROM 的设备可以放下更多的东西。<br>然后 OpenWRT 的恢复出厂设置也要依赖于这个方式。在你捅 Reset 重置的时候，它只需要把 overlay 分区清空就可以了，一切都回到了刚刷进去的样子。<br>如果是 EXT4 文件系统，就只能够备份每个修改的文件，在恢复出厂设置的时候复制回来，十分复杂。<br>当然，SquashFS + overlay 也有它的缺点，修改文件的时候会占用更多的空间。<br>首先你不能够删除文件，因为删除文件实际上是在 overlay 分区中写入一个删除的标识，反而占用更多的空间。<br>另外在修改文件的时候相当于增加了一份文件的副本，占用了双份的空间。</p></blockquote><p><strong>总结来说，overlay文件系统的优点在于只记录修改量，类似于增量更新，非常适合路由器这类小ROM和RAM的嵌入式设备</strong></p><h2 id="网上的备份方法遇到的问题"><a href="#网上的备份方法遇到的问题" class="headerlink" title="网上的备份方法遇到的问题"></a>网上的备份方法遇到的问题</h2><p>目前网上主要有两种完整备份openwrt的方法，</p><h3 id="MTD-Memory-Technology-Device-备份"><a href="#MTD-Memory-Technology-Device-备份" class="headerlink" title="MTD(Memory Technology Device)备份"></a>MTD(Memory Technology Device)备份</h3><p>查看 firmware 所对应的 mtd 编号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@EBIN:~# cat /proc/mtd</span><br><span class="line">dev:    size   erasesize  name</span><br><span class="line">mtd0: 00020000 00010000 &quot;u-boot&quot;</span><br><span class="line">mtd1: 000e43ec 00010000 &quot;kernel&quot;</span><br><span class="line">mtd2: 00eebc14 00010000 &quot;rootfs&quot;</span><br><span class="line">mtd3: 004c0000 00010000 &quot;rootfs_data&quot;</span><br><span class="line">mtd4: 00010000 00010000 &quot;art&quot;</span><br><span class="line">mtd5: 00fd0000 00010000 &quot;firmware&quot;</span><br></pre></td></tr></table></figure><p>使用Linux的 dd命令备份完整固件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd if=/dev/mtd5 of=/tmp/firmware_backup.bin</span><br></pre></td></tr></table></figure><p>连上SSH，比如刷一个新固件，将 firmware_backup.bin 上传到 /tmp 下，利用 mtd 命令恢复</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mtd -r write /tmp/firmware_backup.bin firmware</span><br></pre></td></tr></table></figure><h3 id="仅对-overlay-打包备份"><a href="#仅对-overlay-打包备份" class="headerlink" title="仅对 /overlay 打包备份"></a>仅对 /overlay 打包备份</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -czvf /tmp/overlay_backup.tar.gz /overlay</span><br></pre></td></tr></table></figure><p>需要恢复的时候将 overlay_backup.tar.gz 上传至 /tmp ，然后清空 /overlay 并恢复备份：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rm -rvf /overlay/* </span><br><span class="line">cd /</span><br><span class="line">tar -xzvf /tmp/overlay_backup.tar.gz</span><br></pre></td></tr></table></figure><h2 id="稳妥的办法-只保留设置升级，备份软件包列表，opkg恢复软件包"><a href="#稳妥的办法-只保留设置升级，备份软件包列表，opkg恢复软件包" class="headerlink" title="稳妥的办法:只保留设置升级，备份软件包列表，opkg恢复软件包"></a>稳妥的办法:只保留设置升级，备份软件包列表，opkg恢复软件包</h2><h3 id="What-to-do"><a href="#What-to-do" class="headerlink" title="What to do:"></a>What to do:</h3><p>备份软件包列表</p><p>Make a LIST of all currently install packages:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">opkg list-installed &gt; /etc/config/my_installed_packages</span><br></pre></td></tr></table></figure><p>将备份脚本放到CRONTAB 里面定期执行</p><p>You might want to put the command into a CRON … depending on how much you keep changing the packages on your router:</p><p>EDIT this file, which keeps track of what to SAVE during image upgrades:<br><code>/etc/sysupgrade.conf</code></p><p>AFTER an upgrade run this command:</p><p>勾选保留设置升级(只备份/overlay/upper/etc文件夹的内容(openwrt默认备份内容))之后，用opkg命令恢复已安装的软件包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">opkg update &amp;&amp; opkg list-installed | cut -f 1 -d &#x27; &#x27; | sort -u &gt; /tmp/currentpkg &amp;&amp; cat /etc/config/my_installed_packages | cut -f 1 -d &#x27; &#x27; | sort -u &gt; /tmp/oldpkg &amp;&amp; grep -v -F -x -f /tmp/currentpkg /tmp/oldpkg &gt; /tmp/inst &amp;&amp; opkg install $(cat /tmp/inst | sort -u) &amp;&amp; rm /tmp/currentpkg /tmp/oldpkg /tmp/inst</span><br></pre></td></tr></table></figure><p>This will compare your current (after upgrade)</p><h2 id="exroot挂载-overlay的一些bug"><a href="#exroot挂载-overlay的一些bug" class="headerlink" title="exroot挂载/overlay的一些bug"></a>exroot挂载/overlay的一些bug</h2><p>严格意义上来说不算bug，不过如果你遇到的话，或许这里的解决方法能提供一些帮助</p><p>openwrt的路由器或者主机，在挂载外置SD/TF/U盘为/overlay后，如果遇到升级或者/overlay文件系统UUID不一致无法启动<br>原因是升级21.0.1 -&gt; 21.0.2的openwrt后，原本作为/overlay的外置SD无法启动了，拔掉SD卡正常</p><p>分析kernel.log内核日志，其中有这么一行:<br><code>“block: extroot: UUID mismatch”</code></p><p>UUID和系统/etc/fstab的UUID不一致，导致无法正确挂载SD卡</p><p>原来解决了一下午找不到原因，后来查阅openwrt官方文档：</p><p>If you receive a “block: extroot: UUID mismatch” error in your logs after upgrading, remove .extroot-uuid from the volume:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mount /dev/sda1 /mnt</span><br><span class="line">rm -f /mnt/.extroot-uuid /mnt/etc/.extroot-uuid</span><br><span class="line">umount /mnt</span><br></pre></td></tr></table></figure><p>官方的建议是把exroot的etc/.exroot-uuid删掉，因为这个可能是升级备份前的UUID，与现在挂载的UUID不一致</p><p>顺利解决!!!</p><p>有什么问题还是多看看官方的文档吧，从原理上解决问题，而不是把报错的Log随便扔到google/百度/stackoverflow上面一搜（简单问题除外），这样不利于解决问题，也没法学习到一些系统的底层框架的原理。</p>]]></content>
      
      
      <categories>
          
          <category> openwrt </category>
          
          <category> overlayfs </category>
          
          <category> backup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> openwrt </tag>
            
            <tag> overlayfs </tag>
            
            <tag> backup </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>甘肃白银马拉松事故-天气再分析</title>
      <link href="/en/2021/05/26/2021/marathon/"/>
      <url>/en/2021/05/26/2021/marathon/</url>
      
        <content type="html"><![CDATA[<p>#骑行# #旅行志# #天气#<br>5月22日，一个冷涡在甘肃抛下大量冷空气，在乌鞘岭余脉上诱发了致命的狂风冰雨，多位久负盛名的越野“跑神”永远失去生命。这场狂风冰雨到底有多极端，才能酿成如此灾难？</p><p>事情还是要从那个靠近我国的巨型冷涡说起。5月20-21日，它来到新疆；5月22-23日，它先后掠过西北、华北，23日晚已来到黑龙江西界。冷涡所到之处，北方皆有降温，其中新疆、内蒙古降温猛烈，阿勒泰一度逼近0度，内蒙古发布了寒潮预警。</p><p><img src="/en/2021/05/26/2021/marathon/0.jpg"><br>5月21-22日，河西五市将会有降温，幅度为4-6度；景泰气象台也发了大风蓝色预警。而在此之前，白银市景泰县阳光普照，气温节节攀升，5月21日下午最高已达25.6度，站在太阳下，是妥妥的夏天感觉。</p><p>一边是阳光烘烤下的夏天气息，一边是有寒冬实力的巨大冷涡，极端天气就此酝酿。5月22日早晨，冷涡中心来到毛乌素沙漠以北，大量寒冷空气从几千米的高空“跳伞”，俯冲进入黄河上游地区，一道巨大的冷锋云带在甘肃、宁夏和内蒙古形成。</p><p>————以上内容摘自中国气象爱好者—————–</p><p>欧洲中期天气预报中心（European Centre for Medium-Range Weather Forecasts 简称 ECMWF）是一个包括34个国家支持的国际性组织，是当今全球独树一帜的国际性天气预报研究和业务机构</p><p>ECMWF与世界各国气象预报机构在天气预报领域有广泛的联系。ECMWF主要提供10天的中期数值预报产品，各成员国通过专用的区域气象数据通信网络得到这些产品后做出各自的中期预报，同时ECMWF也通过由世界气象组织（WMO）维护的全球通信网络向世界所有国家发送部分有用的中期数值预报产品。其使用的模式充分利用四维同化资料，可提供全球在65公里高度内60层的40公里网格密度共20，911，680个点的风、温、湿预报</p><p>如果我们用欧洲中期天气ECMWF预报的模型再来重现一下当时的天气，分析这次事故的天气大环境,这样的极端天气是否能被预测到呢？又有哪些措施可以防止悲剧再次发生呢？</p><p>借助于ECMWF强大的再分析模型，我们选择时间点为2021年5月22日上午8点 ，地点黄河石林景区入口</p><p>此时，根据数值预报模型，西边几十公里的新堡乡下起了小雪，而此时景泰县和比赛地也下起了小雨，如下图（白点为黄河石林景区入口，比赛起点）</p><p>上午9点，比赛正式开始。上午11点，此时景泰县和比赛地也下起了中雨，西边几十公里下起了中雪，由于换装点在CP3，选手只能在短袖短裤的装备下着奔跑</p><p><img src="/en/2021/05/26/2021/marathon/sign-1.jpg"><br><img src="/en/2021/05/26/2021/marathon/sign-2.jpg"></p><p>我们再来看看白天比赛时的温度和风速如何：</p><p>拖动时间条，我们分析发现，比赛开始时，气温尚有10-11度，到了下午14点，气温已经低到5-6度了，16：00稍有回升，但仍只有7-8度（想象一下大冬天洗完澡在大街上站着几个小时）</p><p><img src="/en/2021/05/26/2021/marathon/temp-1.jpg"><br><img src="/en/2021/05/26/2021/marathon/temp-2.jpg"><br><img src="/en/2021/05/26/2021/marathon/temp-3.jpg"></p><p>稍微有点常识的人也知道，这种天气相当于南方大部分的冬天，绝不能短袖短裤在户外长时间活动，主办方这点可能根本没有考虑到。</p><p>再来看看风速：</p><p><img src="/en/2021/05/26/2021/marathon/wind-1.jpg"><br><img src="/en/2021/05/26/2021/marathon/wind-2.jpg"><br><img src="/en/2021/05/26/2021/marathon/wind-3.jpg"></p><p>从风速可以看出，从早上7点到下午13点，风速一直都是30-40km/h，14：00才慢慢减弱到20-30km/h，这和参赛选手对风和天气的描述是一致的。</p><p>这些气息参数下，可以想见是多么致命的风寒，冬天寒潮南下时，大家都有这样的经验：同样的温度，刮风比不刮风冷，刮大风比刮小风冷，这就是风寒效应。如果刮风的同时还下雨，会冷上加冷；如果你淋了雨，又暴露在刮风下雨的环境中，会冷上加冷再加冷，因为大风会迫使你身上的水蒸发，再带走热量。</p><p>通过以上ECMWF气象模型的再分析,再结合当地气象部门的数据，我们可以推测出，这样的极端天气，其实是完全可以预测出来的。更何况当地气象部门已经在前一天发布了大风蓝色预警，比赛主办方更应该对此高度重视。</p><p>如果我们把数值模型的生成时间调整到比赛开始前一天，这些预测结果与第二天相差无几，说明这样的低温和大风，也是完全可以预测的。</p><p>那么，对于今后的户外活动，我们应该怎么去规避风险呢？<br>一是主办方需要相应的应急预案，这是首要的，你要考虑到活动可能遭受到的风险和危险，要有足够的后备资源和救援人力来应对<br>另外我有一个比较好的建议，如果是户外活动不太确定或者山区偏远地区的天气，查看数值天气预报，因为传统天气预报是点对点的，主要针对人口密集的城市，那么对于偏远户外山区的预报，可能不太精准，那么，良好的应急预案是首要的，针对户外的天气，重大户外活动建议与当地气象部门报备，这样可以针对性的获取极端天气的预报。</p><p>个人和小团体出游呢，如果是户外徒步项目，带够足够的衣物和干粮，找有经验的领队，切忌独自冒险他，天气可以参考晴天钟等数值模型应用，做好良好的应急预案</p><p>顺便打个软广：我这边可以为各种户外徒步露营摄影项目提供一些天气咨询服务，数据专业准确可靠！也可查询历史天气记录 ，也只收取一点辛苦费，毕竟这些ECMWF数据也是需要一年几千r的授权费的<br><a href="https://www.coolapk.com/feed/27224865?shareKey=ODBmYWE0NDk1OWJmNjBhZTRlMWU~&amp;shareUid=1249995&amp;shareFrom=com.coolapk.market_11.2.2">https://www.coolapk.com/feed/27224865?shareKey=ODBmYWE0NDk1OWJmNjBhZTRlMWU~&amp;shareUid=1249995&amp;shareFrom=com.coolapk.market_11.2.2</a></p>]]></content>
      
      
      <categories>
          
          <category> 户外 </category>
          
          <category> outdoor </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 马拉松 </tag>
            
            <tag> marathon </tag>
            
            <tag> 户外 </tag>
            
            <tag> outdoor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vim-switch-tab shortcut</title>
      <link href="/en/2021/04/19/2021/vim-switch-tab/"/>
      <url>/en/2021/04/19/2021/vim-switch-tab/</url>
      
        <content type="html"><![CDATA[<blockquote><p>you can open another file while vim is open with :tabe filename and to switch to the other file you type :tabn or :tabp for next and previous accordingly.<br>The keyboard shortcuts gT and gt can also be used to switch tabs when you are not in editing mode (i.e. not in insert, replace etc modes). On some systems Ctrl+Alt+Page Up and Ctrl+Alt+Page Down also allow tab-switching, but this does not always work (for example, it won’t work in the OS X terminal ‘out of the box’).</p></blockquote><p><a href="https://unix.stackexchange.com/questions/27586/how-can-i-edit-multiple-files-in-vim"></a></p><table><thead><tr><th align="center">shortcut</th><th align="center">function</th></tr></thead><tbody><tr><td align="center"><code>:tabn</code> <code>:tabp</code></td><td align="center">next and previous accordingly</td></tr><tr><td align="center"><code>gt</code> <code>gT</code></td><td align="center">switch tabs when you are not in editing mode</td></tr><tr><td align="center"><code>Ctrl</code>+<code>Alt</code>+<code>Page</code> <code>Down</code>OR<code>Up</code></td><td align="center">tab-switching</td></tr><tr><td align="center"><code>:tabe</code> <code>filename</code></td><td align="center">open another file</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> vim </category>
          
          <category> shortcut </category>
          
          <category> nvim </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vim </tag>
            
            <tag> shortcut </tag>
            
            <tag> nvim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>银行家算法 Banker&#39;s Algorithm</title>
      <link href="/en/2021/04/19/2021/Banker&#39;s_Algorithm/"/>
      <url>/en/2021/04/19/2021/Banker&#39;s_Algorithm/</url>
      
        <content type="html"><![CDATA[<p>对于计算机中的死锁，我们有四种处理的方法，分别为预防死锁、避免死锁、检测死锁和解除死锁</p><blockquote><p>The banker’s algorithm is a resource allocation and deadlock avoidance algorithm that tests for safety by simulating the allocation for predetermined maximum possible amounts of all resources, then makes an “s-state” check to test for possible activities, before deciding whether allocation should be allowed to continue.</p></blockquote><blockquote><p>银行家算法（Banker’s Algorithm）是一个<strong>避免死锁</strong>（Deadlock）的著名算法，是由艾兹赫尔·戴克斯特拉在1965年为T.H.E系统设计的一种避免死结产生的演算法.它以银行借贷系统的分配策略为基础，判断并保证系统的安全运行.</p></blockquote><p>银行家算法的名字来源于该算法原本是为银行系统设计的，以确保银行在发放现金贷款时，不会发生不能满足所有客户需要的情况，在OS中可以用它来避免死锁.</p><p>银行家算法的实质就是要设法保证系统动态分配资源后不进入不安全状态，以避免可能产生的死锁</p><ul><li>为实现银行家算法，在系统中必须设置这样四个数据结构:</li></ul><ol><li>可利用资源向量Avaliable.这是一个含有m个元素的数组，其中每一个元素代表一类可利用的资源数目，其初始值是系统所配置的该类全部可用资源的数目，其中的每一个元素代表一类可利用的资源数目，其初始值是系统中所配置的该类全部可用资源的数目，其数值随该类资源的分配和回收而动态的改变.如果$Available[j]=K$，则表示系统中现有$R_j$类资源的最大数目为K.</li><li>最大需求矩阵Max.是一个n×m的矩阵，定义了系统中n个进程中的每一个进程对m类资源的最大需求.如果$Max[i, j]=K$，则表示进程i需要$R_j$类资源的最大数目为K.</li><li>分配矩阵Allocation.是一个n×m的矩阵，定义了系统中每一类资源当前已分配给每一进程的资源数.如果Allocation[i, j]=K，则表示进程i当前已分得$R_j$类资源的数目为K.</li><li>需求矩阵Need.是一个n×m的矩阵，用以表示每一个进程尚需的各类资源数.如果$Need[i, j]=K$，则表示进程i还需要$R_j$类资源K个方能完成其任务.</li></ol><p>它们之间的关系为: $Need[i, j]=Max[i, j]-Allocation[i,j]$</p><h2 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h2><p>设 Request i是进程 $P_i$的请求向量，如果 $Request i[j]=K$，表示进程 $P_i$需要 K 个 $R_j$类型的资源.当 $P_i$发出资源请求后，系统按下述步骤进行检查:</p><p>(1) 如果 $Request i[j]≤Need[i,j]$，便转向步骤(2);否则认为出错，因为它所需要的资源数已超过它所宣布的最大值.</p><p>(2) 如果 $Request i[j]≤Available[j]$，便转向步骤(3);否则，表示尚无足够资源，$P_i$ 须等待.</p><p>(3) 系统试探着把资源分配给进程 $P_i$，并修改下面数据结构中的数值:</p><p>$Available[j]= Available[j]-Request_i[j]$;</p><p>$Allocation[i,j]= Allocation[i,j]+Request_i[j]$;</p><p>$Need[i,j]= Need[i,j]-Request_i[j]$;</p><p>(4) 系统执行<strong>安全性算法</strong>，检查此次资源分配后系统是否处于安全状态.若安全，才正式将资源分配给进程 $P_i$，以完成本次分配;否则，将本次的试探分配作废，恢复原来的资源分配状态，让进程 $P_i$等待.</p><h2 id="安全性算法"><a href="#安全性算法" class="headerlink" title="安全性算法"></a>安全性算法</h2><p>系统所执行的安全性算法可描述如下:</p><p>(1) 设置两个向量:</p><ol><li><p>工作向量 Work，它表示系统可提供给进程继续运行所需的各类资源数目，它含有 m个元素，在执行安全算法开始时，$Work=Available$.</p></li><li><p>Finish，它表示系统是否有足够的资源分配给进程，使之运行完成.开始时先做$Finish[i]=false$;当有足够资源分配给进程时，再令 $Finish[i]=true$.</p></li></ol><p>(2) 从进程集合中找到一个能满足下述条件的进程:</p><ol><li><p>$Finish[i]=false$;</p></li><li><p>$Need[i,j]≤Work[j]$;若找到，执行步骤(3)，否则，执行步骤(4). </p></li></ol><p>(3) 当进程 Pi获得资源后，可顺利执行，直至完成，并释放出分配给它的资源，故应执行:</p><p>$Work[j]= Work[j]+Allocation[i,j];$</p><p>$Finish[i]=true;$</p><p>go to step 2;</p><p>(4) 如果所有进程的 $Finish[i]=true$ 都满足，则表示系统处于安全状态;否则，系统处于不安全状态.</p>]]></content>
      
      
      <categories>
          
          <category> CSAPP </category>
          
          <category> concurrent </category>
          
          <category> 操作系统 </category>
          
          <category> deadlock </category>
          
          <category> 死锁 </category>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
            <tag> concurrent </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> deadlock </tag>
            
            <tag> 死锁 </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哲学家进餐问题(Dining philosophers problem)</title>
      <link href="/en/2021/04/18/2021/Dining_philosophers_problem/"/>
      <url>/en/2021/04/18/2021/Dining_philosophers_problem/</url>
      
        <content type="html"><![CDATA[<blockquote><p>哲学家就餐问题可以这样表述，假设有五位哲学家围坐在一张圆形餐桌旁，做以下两件事情之一：吃饭，或者思考。吃东西的时候，他们就停止思考，思考的时候也停止吃东西。餐桌中间有一大碗意大利面，每位哲学家之间各有一支餐叉。因为用一支餐叉很难吃到意大利面，所以假设哲学家必须用两支餐叉吃东西。他们只能使用自己左右手边的那两支餐叉。哲学家就餐问题有时也用米饭和五根筷子而不是意大利面和餐叉来描述，因为吃米饭必须用两根筷子。<br>如何设计一套规则，使得在哲学家们在完全不交谈，也就是无法知道其他人可能在什么时候要吃饭或者思考的情况下，可以在这两种状态下永远交替下去。</p></blockquote><p><img src="/en/2021/04/18/2021/Dining_philosophers_problem/Dining_philosophers_problem.png"></p><p>假设我们要求哲学家遵守以下规则：</p><pre><code>1. 哲学家在左边的叉子可用（没有其他人拿起）之前处于思考状态。如果左边的叉子可用，就拿起来。2. 哲学家等待右边的叉子可用。如果右边的叉子可用，就拿起来。3. 如果两个叉子都已经拿起来，开始吃意大利面，每次吃面都花费同样的时间。4. 吃完后先放下左边的叉子。5. 然后放下右边的叉子。6. 开始思考（进入一个循环）</code></pre><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;; <span class="comment">//定义信号量数组chopstick[5],并初始化</span></span><br><span class="line">Pi()&#123;  <span class="comment">//i号哲学家的进程</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">P(chopstick[i]); <span class="comment">//取左边筷子</span></span><br><span class="line">P(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);  <span class="comment">//取右边篌子</span></span><br><span class="line">eat;</span><br><span class="line">V(chopstick[i]); <span class="comment">//放回左边筷子</span></span><br><span class="line">V(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);  <span class="comment">//放回右边筷子</span></span><br><span class="line">think;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个解法是失败的，当每个哲学家都拿起左侧的叉子，等待右侧的叉子可用时，就会进入死锁状态，每个哲学家将永远都在等待（右边的）另一个哲学家放下叉子。</p><h2 id="正确的解法"><a href="#正确的解法" class="headerlink" title="正确的解法"></a>正确的解法</h2><ul><li>解法一<br>假设当一个哲学家左右两边的筷子都可用时，才允许他抓起筷子。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;; <span class="comment">//初始化信号量</span></span><br><span class="line">semaphore mutex=l;  <span class="comment">//设置取筷子的信号量</span></span><br><span class="line"></span><br><span class="line">Pi()&#123; <span class="comment">//i号哲学家的进程</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">P(mutex); <span class="comment">//在取筷子前获得互斥量，一次只能由一个哲学家取筷子</span></span><br><span class="line">P(chopstick[i]) ; <span class="comment">//取左边筷子</span></span><br><span class="line">P(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);  <span class="comment">//取右边筷子</span></span><br><span class="line">V(mutex); <span class="comment">//释放取筷子的信号量</span></span><br><span class="line">eat;</span><br><span class="line">V(chopstick[i]);  <span class="comment">//放回左边筷子</span></span><br><span class="line">V(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);  <span class="comment">//放回右边筷子</span></span><br><span class="line">think;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>解法二<br>至多只允许有四位哲学家同时去拿左边的筷子，最终能保证至少有一位哲学家能够进餐，并在用完时能释放出他用过的两只筷子，从而使更多的哲学家能够进餐。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;; <span class="comment">//初始化信号量</span></span><br><span class="line">semaphore eating = <span class="number">4</span>;  <span class="comment">//至多只允许四个哲学家可以同时进餐</span></span><br><span class="line"></span><br><span class="line">Pi()&#123; <span class="comment">//i号哲学家的进程</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">think;</span><br><span class="line">P(eating); <span class="comment">//请求进餐，若是第五个则挨饿</span></span><br><span class="line">P(chopstick[i]); <span class="comment">//取左边筷子</span></span><br><span class="line">P(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]) ;  <span class="comment">//取右边筷子</span></span><br><span class="line">eat;</span><br><span class="line">V(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]) ;  <span class="comment">//放回右边筷子</span></span><br><span class="line">V(chopstick[i]) ;  <span class="comment">//放回左边筷子</span></span><br><span class="line">V(eating); <span class="comment">//释放信号量给其他挨饿的哲学家</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>解法三<br>仅当哲学家的左右两只筷子均可使用，才允许他拿起筷子进餐。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;; <span class="comment">//初始化信号量</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>;  <span class="comment">//设置取筷子的信号量</span></span><br><span class="line"></span><br><span class="line">Pi()&#123; <span class="comment">//i号哲学家的进程</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">think;</span><br><span class="line">P(mutex); <span class="comment">//在去筷子前获得互斥量</span></span><br><span class="line">P(chopstick[i]); <span class="comment">//取左边筷子</span></span><br><span class="line">P(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]) ;  <span class="comment">//取右边筷子</span></span><br><span class="line">V(mutex); <span class="comment">//释放互斥量</span></span><br><span class="line">eat;</span><br><span class="line">V(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]) ;  <span class="comment">//放回右边筷子</span></span><br><span class="line">V(chopstick[i]) ;  <span class="comment">//放回左边筷子</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>解法四<br>规定奇数号哲学家先拿他左边的筷子，然后在去拿右边的筷子；而偶数号哲学家则相反。按此规定，将是1、2号哲学家竞争1号筷子；3、4号哲学家竞争3号筷子。</li></ul><p>即5位哲学家都先竞争奇数号筷子，获得后，再去竞争偶数号筷子，最后总会有一位哲学家能够获得两只筷子而进餐。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;; <span class="comment">//初始化信号量</span></span><br><span class="line"></span><br><span class="line">Pi()&#123; <span class="comment">//i号哲学家的进程</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">think;</span><br><span class="line"><span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">P(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]) ;  <span class="comment">//取右边筷子</span></span><br><span class="line">P(chopstick[i]); <span class="comment">//取左边筷子</span></span><br><span class="line">eat;</span><br><span class="line">V(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]) ;  <span class="comment">//放回右边筷子</span></span><br><span class="line">V(chopstick[i]) ;  <span class="comment">//放回左边筷子</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;   <span class="comment">//奇数哲学家，先左后右</span></span><br><span class="line">P(chopstick[i]); <span class="comment">//取左边筷子</span></span><br><span class="line">P(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]) ;  <span class="comment">//取右边筷子</span></span><br><span class="line">V(mutex); <span class="comment">//释放互斥量</span></span><br><span class="line">eat;</span><br><span class="line">V(chopstick[i]) ;  <span class="comment">//放回左边筷子</span></span><br><span class="line">V(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]) ;  <span class="comment">//放回右边筷子</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>解法五<br>采用AND型信号量机制来解决，即要求每个哲学家先获得两个临界资源（筷子）后方能进餐。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;; <span class="comment">//初始化信号量</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>;  <span class="comment">//设置取筷子的信号量</span></span><br><span class="line"></span><br><span class="line">Pi()&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">think;</span><br><span class="line">P(chopstick[i],chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);</span><br><span class="line">eat;</span><br><span class="line">V(chopstick[i],chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> concurrent </category>
          
          <category> 操作系统 </category>
          
          <category> 多线程 </category>
          
          <category> 死锁 </category>
          
          <category> 信号量 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> concurrent </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> 死锁 </tag>
            
            <tag> 多线程 </tag>
            
            <tag> 信号量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSAPP中并发编程的一些概念总结</title>
      <link href="/en/2021/04/18/2021/concurrent_programming/"/>
      <url>/en/2021/04/18/2021/concurrent_programming/</url>
      
        <content type="html"><![CDATA[<h2 id="volatile类型"><a href="#volatile类型" class="headerlink" title="volatile类型"></a>volatile类型</h2><p>Volatile关键字主要有三个功能：</p><ol><li><p>防止重排序</p></li><li><p>保证可见性</p></li><li><p>保证单次读或写操作的原子性。</p></li></ol><p>volatile修饰的变量发生修改时，volatile会强制刷新主内存.</p><p>在CSAPP的12.16节，有一个badcnt.c示例程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * badcnt.c - An improperly synchronized counter program</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/* $begin badcnt */</span></span><br><span class="line"><span class="comment">/* WARNING: This code is buggy! */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;csapp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread</span><span class="params">(<span class="type">void</span> *vargp)</span>;  <span class="comment">/* Thread routine prototype */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Global shared variable */</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">long</span> cnt = <span class="number">0</span>; <span class="comment">/* Counter */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">long</span> niters;</span><br><span class="line"><span class="type">pthread_t</span> tid1, tid2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check input argument */</span></span><br><span class="line"><span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;usage: %s &lt;niters&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">niters = atoi(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Create threads and wait for them to finish */</span></span><br><span class="line">Pthread_create(&amp;tid1, <span class="literal">NULL</span>, thread, &amp;niters);</span><br><span class="line">Pthread_create(&amp;tid2, <span class="literal">NULL</span>, thread, &amp;niters);</span><br><span class="line">Pthread_join(tid1, <span class="literal">NULL</span>);</span><br><span class="line">Pthread_join(tid2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check result */</span></span><br><span class="line"><span class="keyword">if</span> (cnt != (<span class="number">2</span> * niters))</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;BOOM! cnt=%ld\n&quot;</span>, cnt);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;OK cnt=%ld\n&quot;</span>, cnt);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Thread routine */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread</span><span class="params">(<span class="type">void</span> *vargp)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">long</span> i, niters = *((<span class="type">long</span> *)vargp);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; niters; i++) <span class="comment">//line:conc:badcnt:beginloop</span></span><br><span class="line">cnt++;                   <span class="comment">//line:conc:badcnt:endloop</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* $end badcnt */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><ul><li>$H_i$: The block of instructions at the head of the loop</li><li>$L_i$: The instruction that loads the shared variable cnt into register %$rdx_i$, where %$rdx_i$ denotes the value of register %$rdx$ in thread i</li><li>$U_i$: The instruction that updates (increments) %$rdx_i$</li><li>$S_i$: The instruction that stores the updated value of %$rdx_i$ back to the shared variable cnt</li><li>$T_i$: The block of instructions at the tail of the loop</li></ul></blockquote><p>其中关于%$rdx_i$汇编语言中就能看出volatile类型的特性：从Memory读取变量到寄存器，在寄存器中改变值后，立马写回内存</p><p>volatile关键字首先具有“易变性”，声明为volatile变量编译器会强制要求读内存，相关语句不会直接使用上一条语句对应的的寄存器内容，而是重新从内存中读取。</p><h2 id="并发和并行的区别"><a href="#并发和并行的区别" class="headerlink" title="并发和并行的区别"></a>并发和并行的区别</h2><ul><li><p>Concurrent(Concurrency)  – 并发：一段时间内有多个进程执行，不强调同时执行</p></li><li><p>Parallel(Parallelism)   –  并行：一段时间内有多个进程同时执行，强调同时</p></li></ul><h2 id="semaphore-信号量"><a href="#semaphore-信号量" class="headerlink" title="semaphore(信号量)"></a>semaphore(信号量)</h2><blockquote><p><strong>Semaphores</strong> provide a convenient way to ensure <strong>mutually exclusive</strong> access to shared variables.<br>Binary semaphores whose purpose is to provide mutual exclusion are often called mutexes.</p></blockquote><blockquote><p>A semaphore, s, is a global variable with a nonnegative integer value that can only be manipulated by two special operations, called P and V :</p><ul><li>P(s):If s is nonzero, then P decrements s and returns immediately. If s is zero, then suspend the thread until s becomes nonzero and the process is restarted by a V operation. After restarting, the P operation decrements s and returns control to the caller.</li><li>V(s): The V operation increments s by 1. If there are any threads blocked at a P operation waiting for s to become nonzero, then the V operation restarts exactly one of these threads, which then completes its P operation by decrementing s.</li></ul></blockquote><p>信号量（semaphore）的数据结构为一个值和一个指针，指针指向等待该信号量的下一个进程，是一种特殊的全局变量，确保了进程能够<strong>互斥访问</strong>有限的临界资源，下文称作<code>s</code>，<code>s</code>为非负整数，即$s\ge0$</p><p>信号量的值表示相应资源的使用情况:<br>信号量$s\ge0$时，S表示可用资源的数量;$s\le0$时，表示没有资源可用，绝对值代表当前等待资源的进程数.</p><pre><code>       `P(s)`和`V(s)`是由*Edsger Dijkstra*提出的共享变量的互斥访问机制，旨在解决多线程并发中互斥资源的同步问题       在荷兰语中: P代表proberen(to test)，V代表verhogen(to increment)</code></pre><ul><li><p><code>P(s)</code>: 如果<code>s</code>不为0，执行后请求分配一个资源，S的值减1(<code>s--</code>)；当$s&lt;0$时，表示已经没有可用资源，S的绝对值表示当前等待该资源的进程数。请求者必须等待其他进程释放该类资源，才能继续运行。</p></li><li><p><code>V(s)</code>: 执行后释放一个资源，S的值加1(<code>s++</code>)；若$S&lt;0$，表示有某些进程正在等待该资源，因此要唤醒一个等待状态的进程，使之执行P操作，继续运行下去。</p></li></ul><blockquote><p>The definitions of P and V ensure that a running program can never enter a state where a properly initialized semaphore has a negative value.</p></blockquote><h2 id="临界区-Critical-section"><a href="#临界区-Critical-section" class="headerlink" title="临界区(Critical section)"></a>临界区(Critical section)</h2><p>临界区：阻止多个进程同时进入访问这些共享资源的代码段；</p><p>临界资源：一次只允许一个进程访问的资源；<br>P V操作的一般模式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">P(s)</span><br><span class="line">临界区(Critical section)</span><br><span class="line">V(s)</span><br></pre></td></tr></table></figure><p>P和V是原语操作，其执行不可分割，不可中断，P和V确保了进程不会互相进入临界区，确保了线程安全</p><h2 id="mutex-互斥锁"><a href="#mutex-互斥锁" class="headerlink" title="mutex(互斥锁)"></a>mutex(互斥锁)</h2><blockquote><p>Strictly speaking, a mutex is a locking mechanism used to synchronize access to a resource. Only one task (can be a thread or process based on OS abstraction) can acquire the mutex. It means there is ownership associated with a mutex, and only the owner can release the lock (mutex).</p></blockquote><p>类似于semaphores，保护共享资源。</p><p>mutex（互斥量）也是一种二元的锁机制，只有是（1）和否（0）的两个值，和二元信号量比较相似</p><p>典型的例子就是买票：<br>票是共享资源，现在有两个线程同时过来买票。如果你不用mutex在线程里把票锁住，那么就可能出现“把同一张票卖给两个不同的人（线程）”的情况。</p><h2 id="产生死锁的四个必要条件"><a href="#产生死锁的四个必要条件" class="headerlink" title="产生死锁的四个必要条件"></a>产生死锁的四个必要条件</h2><ol><li>互斥条件：一个资源每次只能被一个进程使用。</li><li>占有且等待：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li><li>不可强行占有:进程已获得的资源，在末使用完之前，不能强行剥夺。</li><li>循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</li></ol><h2 id="可重入性"><a href="#可重入性" class="headerlink" title="可重入性"></a>可重入性</h2><blockquote><p>有一类重要的线程安全函数，叫做可重入函数（reentrant function），其特点在于它们具有这样一种属性：当它们被多个线程调用时，不会引用任何共享数据。</p></blockquote><blockquote><p>如果所有的函数参数都是值传递，并且所有的数据引用都是本地的自动栈变量，那么函数就是显示可重入的。</p></blockquote><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><blockquote><p>We can identify four (nondisjoint) classes of thread-unsafe functions:<br>Class 1: Functions that do not protect shared variables.<br>…<br>Class 2: Functions that keep state across multiple invocations.<br>…<br>Class 3: Functions that return a pointer to a static variable.<br>…<br>Class 4: Functions that call thread-unsafe functions.</p></blockquote><p>一个函数被称为线程安全的（thread-safe），当且仅当被多个线程反复地调用时，他会一直产生正确的结果。</p><blockquote><ul><li>线程不安全函数类：</li></ul></blockquote><blockquote><ol><li>不保护共享变量的函数</li><li>保持跨越多个调用的状态的函数</li><li>返回指向静态变量的指针的函数。结果可能会被另外一个线程覆盖</li><li>调用线程不安全的函数</li></ol></blockquote><h2 id="刻画并行程序的性能"><a href="#刻画并行程序的性能" class="headerlink" title="刻画并行程序的性能"></a>刻画并行程序的性能</h2><p>理想情况下，我们期望运行时间随着核心数的增加线性下降。但实际上不会这样（书上的例子）是大于四个（四核）。他说线程多了，会有上下文切换的开销。并行程序常常被写为每个核上只运行一个线程。</p><p>绝对时间是衡量程序性能的终极标准，但是也有一些有用的相对衡量标准<br>并行程序的加速比（speedup）通常定义为 $S_p = \frac{T_1}{T_p}$ ,p 为处理器核心数，Tk 是在 k 个核上的运行时间。这个公式有时被称为强扩展（strong scaling）。当 T1 是程序顺序执行版本的执行时间时，$S_p$ 称为绝对加速比（absolute speedup），当 $T_1$ 是程序并行版本在一个核上的执行时间时，Sp 称为相对加速比（relative speedup）。绝对加速比能更真实的衡量并行的好处。</p><p>一种相关的测量量称为效率（efficiency），定义为： $E_p = \frac{S_p}{p} = \frac{T_1}{pT_p}$</p><p>加速比还有另外一面，成为弱扩展（weak scaling），在增加处理器数量的同时，增加问题的规模，这样随着处理器数量的增加，每个处理器执行的工作量不变。在这种描述下，加速比和效率被表达为单位时间完成的总工作量。</p><h2 id="消费者生产者问题-Producer-consumer-problem"><a href="#消费者生产者问题-Producer-consumer-problem" class="headerlink" title="消费者生产者问题(Producer-consumer problem)"></a>消费者生产者问题(Producer-consumer problem)</h2><p>生产者消费者问题（英语：Producer-consumer problem），描述了共享固定大小缓冲区(buffer)的两个进程——即所谓的“生产者”和“消费者”，类似于视频播放的缓冲。</p><p>生产者消费者问题在多线程中常见的问题是<strong>竞争(Race)</strong></p><p>不同进程抢着进入临界区，可能会引发<strong>死锁(Deadlock)</strong>,即多个进程握着资源但都在等待对方释放临界资源，但等待永远不可能到来。</p><h2 id="读者写者问题-Reader-Writer-Problem"><a href="#读者写者问题-Reader-Writer-Problem" class="headerlink" title="读者写者问题(Reader-Writer Problem)"></a>读者写者问题(Reader-Writer Problem)</h2><p>读者-写者问题是互斥问题的一个概括。一组并发的线程要访问一个共享对象，有些线程只读对象，其他线程只修改对象。修改的线程叫写者，只读对象的线程叫做读者。写者必须拥有对对象独占的访问，读者可以和其他读者共享对象。</p><p>这个问题有几个变种，分别基于读者和写者的优先级。第一类：读者优先。第二类：写者优先。对这两种读者-写者问题的正确解答可能导致饥饿（starvation）。饥饿就是一个线程无限期地阻塞，无法进展。比如当读者优先级高时，如果读者源源不断，那么写者就可能一直等待。</p><blockquote><p>互斥锁加锁顺序规则：给定所有互斥操作的一个全序，如果每个线程都是以一种顺序获得互斥锁并以相反的顺序释放，那么这个程序就是无死锁的。</p></blockquote><p>CSAPP书上12.25是并发缓冲区同步的例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* $begin sbufc */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;csapp.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sbuf.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Create an empty, bounded, shared FIFO buffer with n slots */</span></span><br><span class="line"><span class="comment">/* $begin sbuf_init */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sbuf_init</span><span class="params">(<span class="type">sbuf_t</span> *sp, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">sp-&gt;buf = Calloc(n, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">sp-&gt;n = n;                       <span class="comment">/* Buffer holds max of n items */</span></span><br><span class="line">sp-&gt;front = sp-&gt;rear = <span class="number">0</span>;        <span class="comment">/* Empty buffer iff front == rear */</span></span><br><span class="line">Sem_init(&amp;sp-&gt;mutex, <span class="number">0</span>, <span class="number">1</span>);      <span class="comment">/* Binary semaphore for locking */</span></span><br><span class="line">Sem_init(&amp;sp-&gt;slots, <span class="number">0</span>, n);      <span class="comment">/* Initially, buf has n empty slots */</span></span><br><span class="line">Sem_init(&amp;sp-&gt;items, <span class="number">0</span>, <span class="number">0</span>);      <span class="comment">/* Initially, buf has zero data items */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* $end sbuf_init */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Clean up buffer sp */</span></span><br><span class="line"><span class="comment">/* $begin sbuf_deinit */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sbuf_deinit</span><span class="params">(<span class="type">sbuf_t</span> *sp)</span></span><br><span class="line">&#123;</span><br><span class="line">Free(sp-&gt;buf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* $end sbuf_deinit */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Insert item onto the rear of shared buffer sp */</span></span><br><span class="line"><span class="comment">/* $begin sbuf_insert */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sbuf_insert</span><span class="params">(<span class="type">sbuf_t</span> *sp, <span class="type">int</span> item)</span></span><br><span class="line">&#123;</span><br><span class="line">P(&amp;sp-&gt;slots);                          <span class="comment">/* Wait for available slot */</span></span><br><span class="line">P(&amp;sp-&gt;mutex);                          <span class="comment">/* Lock the buffer */</span></span><br><span class="line">sp-&gt;buf[(++sp-&gt;rear)%(sp-&gt;n)] = item;   <span class="comment">/* Insert the item */</span></span><br><span class="line">V(&amp;sp-&gt;mutex);                          <span class="comment">/* Unlock the buffer */</span></span><br><span class="line">V(&amp;sp-&gt;items);                          <span class="comment">/* Announce available item */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* $end sbuf_insert */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Remove and return the first item from buffer sp */</span></span><br><span class="line"><span class="comment">/* $begin sbuf_remove */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sbuf_remove</span><span class="params">(<span class="type">sbuf_t</span> *sp)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> item;</span><br><span class="line">P(&amp;sp-&gt;items);                          <span class="comment">/* Wait for available item */</span></span><br><span class="line">P(&amp;sp-&gt;mutex);                          <span class="comment">/* Lock the buffer */</span></span><br><span class="line">item = sp-&gt;buf[(++sp-&gt;front)%(sp-&gt;n)];  <span class="comment">/* Remove the item */</span></span><br><span class="line">V(&amp;sp-&gt;mutex);                          <span class="comment">/* Unlock the buffer */</span></span><br><span class="line">V(&amp;sp-&gt;slots);                          <span class="comment">/* Announce available slot */</span></span><br><span class="line"><span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* $end sbuf_remove */</span></span><br><span class="line"><span class="comment">/* $end sbufc */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>item信号量控制缓冲区剩余的资源量，mutex是缓冲区的互斥锁，slot信号量表示空余的缓冲区</p><blockquote><p>Like the solutions to many synchronization problems, it is subtle and deceptively simple. The w semaphore controls access to the critical sections that access the shared object. The mutex semaphore protects access to the shared readcnt variable, which counts the number of readers currently in the critical section. A writer locks the w mutex each time it enters the critical section, and unlocks it each time it leaves. This guarantees that there is at most one writer in the critical section at any point in time. On the other hand, only the first reader to enter the critical section locks w, and only the last reader to leave the critical section unlocks it. The w mutex is ignored by readers who enter and leave while other readers are present. This means that as long as a single reader holds the w mutex, an unbounded number of readers can enter the critical section unimpeded.</p></blockquote><h3 id="第一个读者-写者解法-读者优先"><a href="#第一个读者-写者解法-读者优先" class="headerlink" title="第一个读者-写者解法(读者优先)"></a>第一个读者-写者解法(读者优先)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Global variables */</span></span><br><span class="line"><span class="type">int</span> readcnt; <span class="comment">/* Initially = 0 */</span></span><br><span class="line"><span class="type">sem_t</span> mutex, w; <span class="comment">/* Both initially = 1 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">reader</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">P(&amp;mutex);</span><br><span class="line">readcnt++;</span><br><span class="line"><span class="keyword">if</span> (readcnt == <span class="number">1</span>) <span class="comment">/* First in */</span></span><br><span class="line">P(&amp;w);</span><br><span class="line">V(&amp;mutex);</span><br><span class="line"><span class="comment">/* Critical section */</span></span><br><span class="line"><span class="comment">/* Reading happens */</span></span><br><span class="line">P(&amp;mutex);</span><br><span class="line">readcnt--;</span><br><span class="line"><span class="keyword">if</span> (readcnt == <span class="number">0</span>) <span class="comment">/* Last out */</span></span><br><span class="line">V(&amp;w);</span><br><span class="line">V(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">writer</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">P(&amp;w);</span><br><span class="line"><span class="comment">/* Critical section */</span></span><br><span class="line"><span class="comment">/* Writing happens */</span></span><br><span class="line">V(&amp;w);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mutex 保护readcnt(代表当前的Reader数量),w保护代码的临界区，确保一段时间只有1个线程在读写</p><h3 id="第二个读者-写者解法-写者优先"><a href="#第二个读者-写者解法-写者优先" class="headerlink" title="第二个读者-写者解法(写者优先)"></a>第二个读者-写者解法(写者优先)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   COPYRIGHT: CSAPP author RB</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* My thoughts</span></span><br><span class="line"><span class="comment">   For the second rw problem, we give the writers have higher priority</span></span><br><span class="line"><span class="comment">   than readers.That is when a writer arrives at some time, it will wait</span></span><br><span class="line"><span class="comment">   all the readers in critical section currently to finish their work,</span></span><br><span class="line"><span class="comment">   and at the same time, prevent any incoming readers entering their critical</span></span><br><span class="line"><span class="comment">   section ,by doing a P operation on r.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NITERS 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Sample code demonstrating reader-writers, using 2nd readers-writers</span></span><br><span class="line"><span class="comment"> * solution</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Create NITERS agents, numbered from 1 to NITERS.  Each agent is</span></span><br><span class="line"><span class="comment"> * randomly chosen to bea reader (probability 80%) or a writer</span></span><br><span class="line"><span class="comment"> * (probability 20%).  Writers assign their ID to the global value.</span></span><br><span class="line"><span class="comment"> * Readers read the global value.  Also insert random delays in agent</span></span><br><span class="line"><span class="comment"> * generation so that writers can catch up to the readers.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;csapp.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Uniform random number in [0.0,1.0] */</span></span><br><span class="line"><span class="type">static</span> <span class="type">double</span> <span class="title function_">uniform</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="type">double</span>) random() / RAND_MAX;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">choose_with_probability</span><span class="params">(<span class="type">double</span> prob)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> uniform() &lt;=  prob;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* $begin reader1 */</span></span><br><span class="line"><span class="comment">/* Global variables */</span></span><br><span class="line"><span class="type">int</span> readcnt, writecnt; <span class="comment">/* All initially = 0 */</span></span><br><span class="line"><span class="type">sem_t</span> rmutex, wmutex, r, w;     <span class="comment">/* All initially = 1 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">readcnt = <span class="number">0</span>;</span><br><span class="line">writecnt = <span class="number">0</span>;</span><br><span class="line">Sem_init(&amp;rmutex, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">Sem_init(&amp;wmutex, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">Sem_init(&amp;w, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">Sem_init(&amp;r, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Get read access to data and read */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ireader</span><span class="params">(<span class="type">int</span> *buf)</span></span><br><span class="line">&#123;</span><br><span class="line">P(&amp;r);   <span class="comment">// Permission to attempt read</span></span><br><span class="line">P(&amp;rmutex);</span><br><span class="line">readcnt++;</span><br><span class="line"><span class="keyword">if</span> (readcnt == <span class="number">1</span>) <span class="comment">/* First in */</span></span><br><span class="line">P(&amp;w); <span class="comment">// Block writers</span></span><br><span class="line">V(&amp;rmutex);</span><br><span class="line">V(&amp;r);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Critical section */</span></span><br><span class="line"><span class="type">int</span> v = *buf;</span><br><span class="line"></span><br><span class="line">P(&amp;rmutex);</span><br><span class="line">readcnt--;</span><br><span class="line"><span class="keyword">if</span> (readcnt == <span class="number">0</span>) <span class="comment">/* Last out */</span></span><br><span class="line">V(&amp;w);</span><br><span class="line">V(&amp;rmutex);</span><br><span class="line"><span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Get write access to data and write */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">iwriter</span><span class="params">(<span class="type">int</span> *buf, <span class="type">int</span> v)</span></span><br><span class="line">&#123;</span><br><span class="line">P(&amp;wmutex);</span><br><span class="line">writecnt++;</span><br><span class="line"><span class="keyword">if</span> (writecnt == <span class="number">1</span>)</span><br><span class="line">P(&amp;r);  <span class="comment">// Block readers</span></span><br><span class="line">V(&amp;wmutex);</span><br><span class="line"></span><br><span class="line">P(&amp;w);</span><br><span class="line"><span class="comment">/* Critical section */</span></span><br><span class="line">*buf = v;</span><br><span class="line"><span class="comment">/* Writing happens  */</span></span><br><span class="line">V(&amp;w);</span><br><span class="line"></span><br><span class="line">P(&amp;wmutex);</span><br><span class="line">writecnt--;</span><br><span class="line"><span class="keyword">if</span> (writecnt == <span class="number">0</span>)</span><br><span class="line">V(&amp;r);  <span class="comment">// Enable readers</span></span><br><span class="line">V(&amp;wmutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> global_value = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">rthread</span><span class="params">(<span class="type">void</span> *vargp)</span> &#123;</span><br><span class="line"><span class="type">int</span> id = *(<span class="type">int</span> *) vargp;</span><br><span class="line">Free(vargp);</span><br><span class="line"><span class="type">int</span> v = ireader(&amp;global_value);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Reader %d read value %d\n&quot;</span>, id, v);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">wthread</span><span class="params">(<span class="type">void</span> *vargp)</span> &#123;</span><br><span class="line"><span class="type">int</span> id = *(<span class="type">int</span> *) vargp;</span><br><span class="line">Free(vargp);</span><br><span class="line">iwriter(&amp;global_value, id);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Writer %d wrote value %d\n&quot;</span>, id, id);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line"><span class="type">int</span> niters = NITERS;</span><br><span class="line"><span class="keyword">if</span> (argc &gt; <span class="number">1</span>)</span><br><span class="line">niters = atoi(argv[<span class="number">1</span>]);</span><br><span class="line"><span class="type">pthread_t</span> tid[niters];</span><br><span class="line">init();</span><br><span class="line"><span class="type">int</span> id;</span><br><span class="line"><span class="keyword">for</span> (id = <span class="number">1</span>; id &lt;= niters; id++) &#123;</span><br><span class="line"><span class="type">bool</span> doread = choose_with_probability(<span class="number">0.8</span>);</span><br><span class="line"><span class="type">void</span> *vargp = Malloc(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">*(<span class="type">int</span> *) vargp = id;</span><br><span class="line">Pthread_create(&amp;tid[id<span class="number">-1</span>], <span class="literal">NULL</span>,</span><br><span class="line">doread ? rthread : wthread,</span><br><span class="line">vargp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (id = <span class="number">1</span>; id &lt;= niters; id++) &#123;</span><br><span class="line">Pthread_join(tid[id<span class="number">-1</span>], <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CSAPP </category>
          
          <category> concurrent </category>
          
          <category> 操作系统 </category>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
            <tag> concurrent </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Github action自动部署Hexo博客到Github pages</title>
      <link href="/en/2021/04/17/2021/Hexo-deploy-action/"/>
      <url>/en/2021/04/17/2021/Hexo-deploy-action/</url>
      
        <content type="html"><![CDATA[<p>hexo 博客如果是部署在 <code>github page</code> 上的话，可以通过 <code>Github action</code> 实现自动部署，免去手动生成上传的麻烦，每次修改将源码提交即可自动开始部署</p><p>示例Github action代码</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Deploy</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Controls when the action will run. </span></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="comment"># Triggers the workflow on push or pull request events but only for the master branch</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span> [ <span class="string">main</span> ]</span><br><span class="line">  <span class="attr">pull_request:</span></span><br><span class="line">    <span class="attr">branches:</span> [ <span class="string">main</span> ]</span><br><span class="line"></span><br><span class="line">  <span class="comment"># Allows you to run this workflow manually from the Actions tab</span></span><br><span class="line">  <span class="attr">workflow_dispatch:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">A</span> <span class="string">job</span> <span class="string">to</span> <span class="string">deploy</span> <span class="string">blog.</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/checkout@v1</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">submodules:</span> <span class="literal">true</span> <span class="comment"># Checkout private submodules(themes or something else).</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">apt</span> <span class="string">install</span> <span class="string">&amp;</span> <span class="string">upgrade</span> <span class="string">nodejs</span> <span class="string">&amp;</span> <span class="string">install</span> <span class="string">hexo</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">           node -v</span></span><br><span class="line"><span class="string">           echo &quot;-------------&quot;</span></span><br><span class="line"><span class="string">           curl -fsSL https://deb.nodesource.com/setup_lts.x | sudo -E bash -</span></span><br><span class="line"><span class="string">           sudo apt-get install -y nodejs</span></span><br><span class="line"><span class="string">           echo &quot;-------------&quot;</span></span><br><span class="line"><span class="string">           node -v</span></span><br><span class="line"><span class="string">           sudo npm install -g hexo hexo-cli</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">--save</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">              ls</span></span><br><span class="line"><span class="string">              npm install --save</span></span><br><span class="line"><span class="string"></span>    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Git</span> <span class="string">Global</span> <span class="string">variable</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">              git config --global user.email &quot;Your email&quot;</span></span><br><span class="line"><span class="string">              git config --global user.name &quot;Your name&quot;</span></span><br><span class="line"><span class="string">              git config --global init.defaultBranch main</span></span><br><span class="line"><span class="string"></span>    </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Hexo</span> <span class="string">deploy</span> <span class="string">key</span></span><br><span class="line">      <span class="attr">env:</span></span><br><span class="line">          <span class="attr">ACTION_DEPLOY_KEY:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.HEXO_DEPLOY_KEY</span> <span class="string">&#125;&#125;</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          mkdir -p ~/.ssh/</span></span><br><span class="line"><span class="string">          echo &quot;$ACTION_DEPLOY_KEY&quot; &gt; ~/.ssh/id_rsa</span></span><br><span class="line"><span class="string">          chmod 700 ~/.ssh</span></span><br><span class="line"><span class="string">          chmod 600 ~/.ssh/id_rsa</span></span><br><span class="line"><span class="string">          ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts</span></span><br><span class="line"><span class="string"></span>        </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">hexo</span> <span class="string">generate</span> <span class="string">&amp;</span> <span class="string">deploy</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">              ls</span></span><br><span class="line"><span class="string">              echo &quot;Generate  hexo site&quot;</span></span><br><span class="line"><span class="string">              hexo g</span></span><br><span class="line"><span class="string">              echo &quot;--------------&quot;</span></span><br><span class="line"><span class="string">              cd ..</span></span><br><span class="line"><span class="string">              pwd</span></span><br><span class="line"><span class="string">              echo &quot;Tree -L 2&quot;</span></span><br><span class="line"><span class="string">              tree -L 2</span></span><br><span class="line"><span class="string">              echo &quot;Deploy  hexo site&quot;</span></span><br><span class="line"><span class="string">              hexo d</span></span><br></pre></td></tr></table></figure><h2 id="GitHub-Deploy-key配置"><a href="#GitHub-Deploy-key配置" class="headerlink" title="GitHub Deploy key配置"></a>GitHub Deploy key配置</h2><ul><li>在Linux命令行输入</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;hexo&quot;</span></span><br></pre></td></tr></table></figure><ul><li><p>生成RSA加密的ssh密钥对,位于当前目录下,<code>hexo.pub</code>为公钥,<code>hexo</code>为私钥</p></li><li><p>复制<code>hexo.pub</code>内容到<code>Settings</code> -&gt; <code>Deploy key</code>的新建项</p></li><li><p>在<code>Settings</code> -&gt; <code>Secret key</code>创建<code>HEXO_DEPLOY_KEY</code>,<code>value</code>为刚刚生成的<code>hexo</code>私钥内容</p></li><li><p>根据需要修改<code>deploy.yml</code>内容创建自动部署Hexo的Action</p></li></ul><p>这样在每次push到仓库的时候都能等1min左右完成Github page的自动生成部署</p><h2 id="需要注意的"><a href="#需要注意的" class="headerlink" title="需要注意的"></a>需要注意的</h2><ul><li><code>hexo</code> 依赖于<code>Nodejs</code>的<code>npm</code>包管理器,请现在本地参照<a href="https://hexo.io/zh-cn/docs/">Hexo官方文档</a>部署后，在Git项目中添加<code>.gitignore</code>忽略掉以下内容的提交,不上传<code>node_modules</code>等依赖文件，GithubAction会根据<code>npm install --save</code>生成的<code>package.json</code>自动安装配置相关npm包的依赖(即<code>package.json</code>包含npm包的依赖信息):</li></ul><p>.gitignore内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.DS_Store</span><br><span class="line">Thumbs.db</span><br><span class="line">db.json</span><br><span class="line">*.log</span><br><span class="line">node_modules/</span><br><span class="line">public/</span><br><span class="line">.deploy*/</span><br><span class="line">package-lock.json</span><br></pre></td></tr></table></figure><p><strong>请在Private repo中提交源码，防止Token可能公开带来安全性问题</strong></p>]]></content>
      
      
      <categories>
          
          <category> github action </category>
          
          <category> 自动化部署 </category>
          
          <category> hexo </category>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github action </tag>
            
            <tag> 自动化部署 </tag>
            
            <tag> hexo </tag>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>coc-vimrc</title>
      <link href="/en/2021/04/15/2021/coc-vimrc/"/>
      <url>/en/2021/04/15/2021/coc-vimrc/</url>
      
        <content type="html"><![CDATA[<p><strong>This is my coc-nvim configuration file document</strong></p><p>refer <strong><a href="https://github.com/zhzhzhy/coc-vimrc">Here</a></strong> in Github repository for more detail</p><h1 id="coc-vimrc"><a href="#coc-vimrc" class="headerlink" title="coc-vimrc"></a>coc-vimrc</h1><p><strong>Configuration of my coc-nvim &amp; Vimrc</strong></p><h2 id="Vim-Installation"><a href="#Vim-Installation" class="headerlink" title="Vim Installation"></a>Vim Installation</h2><h3 id="Installation-Guide"><a href="#Installation-Guide" class="headerlink" title="Installation Guide"></a><a href="https://www.vim.org/download.php">Installation Guide</a></h3><h3 id="Github-page"><a href="#Github-page" class="headerlink" title="Github page"></a><a href="https://github.com/vim/vim">Github page</a></h3><h2 id="Neovim-Installation-Optional"><a href="#Neovim-Installation-Optional" class="headerlink" title="Neovim Installation(Optional)"></a>Neovim Installation(Optional)</h2><p><a href="https://neovim.io/"><img src="/en/2021/04/15/2021/coc-vimrc/neovim-logo-300x87.png" alt="Neovim"></a></p><p>Neovim is a project that seeks to aggressively refactor Vim in order to:</p><ul><li>Simplify maintenance and encourage <a href="CONTRIBUTING.md">contributions</a></li><li>Split the work between multiple developers</li><li>Enable [advanced UIs] without modifications to the core</li><li>Maximize <a href="https://github.com/neovim/neovim/wiki/Plugin-UI-architecture">extensibility</a></li></ul><p>See the <a href="https://github.com/neovim/neovim/wiki/Introduction">Introduction</a> wiki page and [Roadmap]<br>for more information.</p><h3 id="Neovim-Installation-guide"><a href="#Neovim-Installation-guide" class="headerlink" title="Neovim Installation guide"></a>Neovim Installation guide</h3><ul><li><p><a href="https://neovim.io/">Neovim website</a></p></li><li><p><a href="https://github.com/neovim/neovim/wiki/Installing-Neovim">Installation Guide</a></p></li></ul><h2 id="coc-nvim-Installation"><a href="#coc-nvim-Installation" class="headerlink" title="coc-nvim Installation"></a>coc-nvim Installation</h2><ul><li>First Install <a href="https://github.com/neoclide/coc.nvim">coc-nvim</a><br>Don’t forget to install <code>nodejs</code> and <code>npm</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install nodejs npm</span><br></pre></td></tr></table></figure><p>OR</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S nodejs npm</span><br></pre></td></tr></table></figure><p>Note: If you are in China,change the <strong>npm source</strong>(Taobao registry) by following command</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><h2 id="Plug-vim-Install"><a href="#Plug-vim-Install" class="headerlink" title="Plug.vim Install"></a><a href="https://github.com/junegunn/vim-plug">Plug.vim</a> Install</h2><p>A minimalist Vim plugin manager.</p><img src="https://raw.githubusercontent.com/junegunn/i/master/vim-plug/installer.gif" height="450"><h3 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h3><p><a href="https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim">Download plug.vim</a><br>and put it in the “autoload” directory.</p><h4 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h4><h5 id="Unix"><a href="#Unix" class="headerlink" title="Unix"></a>Unix</h5><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -fLo ~/.vim/autoload/plug.vim --create-dirs \</span><br><span class="line">    https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim</span><br></pre></td></tr></table></figure><p>You can automate the process by putting the command in your Vim configuration<br>file as suggested <a href="https://github.com/junegunn/vim-plug/wiki/tips#automatic-installation">here</a>.</p><h5 id="Windows-PowerShell"><a href="#Windows-PowerShell" class="headerlink" title="Windows (PowerShell)"></a>Windows (PowerShell)</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">iwr</span> <span class="literal">-useb</span> https://raw.githubusercontent.com/junegunn/vim<span class="literal">-plug</span>/master/plug.vim |`</span><br><span class="line">    <span class="built_in">ni</span> <span class="variable">$HOME</span>/vimfiles/autoload/plug.vim <span class="literal">-Force</span></span><br></pre></td></tr></table></figure><h4 id="Neovim"><a href="#Neovim" class="headerlink" title="Neovim"></a>Neovim</h4><h5 id="Unix-Linux"><a href="#Unix-Linux" class="headerlink" title="Unix, Linux"></a>Unix, Linux</h5><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sh -c <span class="string">&#x27;curl -fLo &quot;$&#123;XDG_DATA_HOME:-$HOME/.local/share&#125;&quot;/nvim/site/autoload/plug.vim --create-dirs \</span></span><br><span class="line"><span class="string">       https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim&#x27;</span></span><br></pre></td></tr></table></figure><h5 id="Linux-Flatpak"><a href="#Linux-Flatpak" class="headerlink" title="Linux (Flatpak)"></a>Linux (Flatpak)</h5><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -fLo ~/.var/app/io.neovim.nvim/data/nvim/site/autoload/plug.vim \</span><br><span class="line">    https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim</span><br></pre></td></tr></table></figure><h5 id="Windows-PowerShell-1"><a href="#Windows-PowerShell-1" class="headerlink" title="Windows (PowerShell)"></a>Windows (PowerShell)</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">iwr</span> <span class="literal">-useb</span> https://raw.githubusercontent.com/junegunn/vim<span class="literal">-plug</span>/master/plug.vim |`</span><br><span class="line">    <span class="built_in">ni</span> <span class="string">&quot;<span class="variable">$</span>(@(<span class="variable">$env:XDG_DATA_HOME</span>, <span class="variable">$env:LOCALAPPDATA</span>)[<span class="variable">$null</span> -eq <span class="variable">$env:XDG_DATA_HOME</span>])/nvim-data/site/autoload/plug.vim&quot;</span> <span class="literal">-Force</span></span><br></pre></td></tr></table></figure><h2 id="Vim-amp-Neovim-configuration-How-to-use-these-scripts"><a href="#Vim-amp-Neovim-configuration-How-to-use-these-scripts" class="headerlink" title="Vim &amp; Neovim configuration: How to use these scripts"></a>Vim &amp; Neovim configuration: How to use these scripts</h2><p><strong>Notice</strong>: These config files suit my own needs,Please <strong>DO NOT</strong> just copy this configuration folder without really understanding about it! Please, at least, read this README file!</p><h3 id="For-Vim"><a href="#For-Vim" class="headerlink" title="For Vim"></a>For Vim</h3><ol><li><p>After you install <code>Plug.vim</code>,copy <code>.vimrc</code> and <code>coc-settings.json</code> Scripts to <code>$HOME/</code> &amp; <code>$HOME/.vim/</code></p></li><li><p>Reopen <code>Vim</code></p></li><li><p>Wait Coc Extension installing finished</p></li><li><p>Execute <code>:PlugInstall</code> to Finish VIM Plugin install</p></li><li><p>Configure the rest components</p></li></ol><h3 id="For-Neovim"><a href="#For-Neovim" class="headerlink" title="For Neovim"></a>For Neovim</h3><ol><li>After you install <code>Plug.vim</code>,copy <code>init.vim</code> to <code>$HOME/.config/nvim/</code></li><li>Reopen <code>Neovim</code></li></ol><h2 id="Neovim-Transitioning-from-Vim-nvim-from-vim"><a href="#Neovim-Transitioning-from-Vim-nvim-from-vim" class="headerlink" title="Neovim: Transitioning from Vim (nvim-from-vim)"></a>Neovim: Transitioning from Vim (<em>nvim-from-vim</em>)</h2><p><em>nvim-from-vim</em></p><ol><li>To start the transition, create your <a href="https://neovim.io/doc/user/init.html">init.vim</a> (user <a href="https://neovim.io/doc/user/starting.html#config">config</a>) file:</li></ol><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:<span class="keyword">call</span> <span class="built_in">mkdir</span>(stdpath(<span class="string">&#x27;config&#x27;</span>), <span class="string">&#x27;p&#x27;</span>)</span><br><span class="line">:<span class="keyword">exe</span> <span class="string">&#x27;edit &#x27;</span>.stdpath(<span class="string">&#x27;config&#x27;</span>).<span class="string">&#x27;/init.vim&#x27;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>Add these contents to the file:</li></ol><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> runtimepath^=~/.<span class="keyword">vim</span> runtimepath+=~/.<span class="keyword">vim</span>/after</span><br><span class="line"><span class="keyword">let</span> &amp;packpath = &amp;runtimepath</span><br><span class="line"><span class="keyword">source</span> ~/.vimrc</span><br></pre></td></tr></table></figure><ol start="3"><li>Restart Nvim, your existing Vim <a href="https://neovim.io/doc/user/starting.html#config">config</a> will be loaded.</li></ol><p>See |<a href="https://neovim.io/doc/user/provider.html#provider-python">provider-python</a>| and |<a href="https://neovim.io/doc/user/provider.html#provider-clipboard">provider-clipboard</a>| for additional software you<br>might need to use some features.</p><p>Your Vim configuration might not be entirely Nvim-compatible.<br>See |<a href="https://neovim.io/doc/user/vim_diff.html#vim-differences">vim-differences</a>| for the full <a href="https://neovim.io/doc/user/eval.html#list">list</a> of changes.</p><p>The |<a href="https://neovim.io/doc/user/vim_diff.html#'ttymouse'">‘ttymouse’</a>| option, for example, was removed from Nvim (mouse support<br>should work without <a href="https://neovim.io/doc/user/motion.html#it">it</a>). If you use the same |<a href="https://neovim.io/doc/user/starting.html#vimrc">vimrc</a>| for Vim and Nvim,<br>consider guarding |<a href="https://neovim.io/doc/user/vim_diff.html#'ttymouse'">‘ttymouse’</a>| in your configuration like so:</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> !has(<span class="string">&#x27;nvim&#x27;</span>)</span><br><span class="line">    <span class="keyword">set</span> ttymouse=xterm2</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure><p>Conversely, if you have Nvim specific configuration items, you could do<br>this:</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">has</span>(<span class="string">&#x27;nvim&#x27;</span>)</span><br><span class="line">    tnoremap <span class="symbol">&lt;Esc&gt;</span> &lt;C-\&gt;<span class="symbol">&lt;C-n&gt;</span></span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure><p>For a more granular approach use YXXYexists()|:</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">exists</span>(<span class="string">&#x27;:tnoremap&#x27;</span>)</span><br><span class="line">    tnoremap <span class="symbol">&lt;Esc&gt;</span> &lt;C-\&gt;<span class="symbol">&lt;C-n&gt;</span></span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure><p>Now you should be able to explore Nvim more comfortably. Check |<a href="https://neovim.io/doc/user/vim_diff.html#nvim-features">nvim-features</a>| for more information.</p><h2 id="Plugin-explanation-amp-key-mapping"><a href="#Plugin-explanation-amp-key-mapping" class="headerlink" title="Plugin explanation &amp; key mapping"></a>Plugin explanation &amp; key mapping</h2><h3 id="vim-plugins"><a href="#vim-plugins" class="headerlink" title="vim plugins"></a>vim plugins</h3><h4 id="coc-nvim"><a href="#coc-nvim" class="headerlink" title="coc.nvim"></a><a href="https://github.com/neoclide/coc.nvim">coc.nvim</a></h4><p>Follow <a href="#installation">Installation</a></p><h4 id="kotlin-vim"><a href="#kotlin-vim" class="headerlink" title="kotlin-vim"></a><a href="https://github.com/udalov/kotlin-vim">kotlin-vim</a></h4><h4 id="vim-visual-multi"><a href="#vim-visual-multi" class="headerlink" title="vim-visual-multi"></a><a href="https://github.com/mg979/vim-visual-multi">vim-visual-multi</a></h4><table><thead><tr><th align="center">Shortcut</th><th align="center">Action</th></tr></thead><tbody><tr><td align="center"><code>Ctrl</code>+<code>n</code></td><td align="center"><strong>Select next key (multiple cursors)</strong></td></tr><tr><td align="center"><code>q</code></td><td align="center"><strong>Deselect the current keys (multiple cursors)</strong></td></tr><tr><td align="center"><code>N</code></td><td align="center">Select the previous key</td></tr><tr><td align="center"><code>n</code></td><td align="center">Select the next key</td></tr><tr><td align="center"><code>Esc</code></td><td align="center">Quit mutiple cursors</td></tr></tbody></table><p>To minimize chances for conflicts, a leader that is specific to VM is defined. The default is <code>\\</code> (two backslashes), but you can change it by setting:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let g:VM_leader = &#123;your VM leader&#125;</span><br></pre></td></tr></table></figure><h5 id="Basic-usage"><a href="#Basic-usage" class="headerlink" title="Basic usage:"></a>Basic usage:</h5><ul><li>select words with <kbd>Ctrl-N</kbd> (like <code>Ctrl-d</code> in Sublime Text/VS Code)</li><li>create cursors vertically with <kbd>Ctrl-Down</kbd>/<kbd>Ctrl-Up</kbd></li><li>select one character at a time with <kbd>Shift-Arrows</kbd></li><li>press <kbd>n</kbd>/<kbd>N</kbd> to get next/previous occurrence</li><li>press <kbd>[</kbd>/<kbd>]</kbd> to select next/previous cursor</li><li>press <kbd>q</kbd> to skip current and get next occurrence</li><li>press <kbd>Q</kbd> to remove current cursor/selection</li><li>start insert mode with <kbd>i</kbd>,<kbd>a</kbd>,<kbd>I</kbd>,<kbd>A</kbd></li></ul><p>Two main modes:</p><ul><li>in <em>cursor mode</em> commands work as they would in normal mode</li><li>in <em>extend mode</em> commands work as they would in visual mode</li><li>press <kbd>Tab</kbd> to switch between «cursor» and «extend» mode</li></ul><p>Most vim commands work as expected (motions, <kbd>r</kbd> to replace characters, <kbd>~</kbd> to change case, etc). Additionally you can:</p><ul><li>run macros/ex/normal commands at cursors</li><li>align cursors</li><li>transpose selections</li><li>add patterns with regex, or from visual mode</li></ul><p>And more… of course, you can enter insert mode and autocomplete will work.</p><h5 id="Documentation"><a href="#Documentation" class="headerlink" title="Documentation"></a>Documentation</h5><pre><code>:help visual-multi</code></pre><p>For some specific topic it’s often:</p><pre><code>:help vm-some-topic</code></pre><h5 id="Wiki"><a href="#Wiki" class="headerlink" title="Wiki"></a><a href="https://github.com/mg979/vim-visual-multi/wiki">Wiki</a></h5><p>The wiki was the first documentation for the plugin, but many pictures are<br>outdated and contain wrong mappings. Still, you can take a look.</p><p>You could read at least the <a href="https://github.com/mg979/vim-visual-multi/wiki/Quick-start">Quick Start</a>.</p><p> Quick refer the <a href="https://github.com/mg979/vim-visual-multi/wiki/Mappings">Key mapping</a></p><p>Insert mode with autocomplete, alignment (mappings in pic have changed, don’t trust them)</p><p><img src="/en/2021/04/15/2021/coc-vimrc/u5pPY5W.gif" alt="Imgur"></p><hr><p>Undo/Redo edits and selections</p><p><img src="/en/2021/04/15/2021/coc-vimrc/gwFfUxq.gif" alt="Imgur"></p><hr><p>Alternate cursor/extend mode, motions (even %), reverse direction (as in visual mode) and extend from the back. At any time you can switch from extend to cursor mode and viceversa.</p><p><img src="/en/2021/04/15/2021/coc-vimrc/ggQr1Ve.gif" alt="Imgur"></p><hr><p>Select inside/around brackets/quotes/etc:</p><p><img src="/en/2021/04/15/2021/coc-vimrc/GAXQLao.gif" alt="Imgur"></p><hr><p>Select operator, here shown with ‘wellle/targets.vim’ plugin: sib, sia, saa + selection shift</p><p><img src="/en/2021/04/15/2021/coc-vimrc/yM3Fele.gif" alt="Imgur"></p><hr><p>Synched column transposition</p><p><img src="/en/2021/04/15/2021/coc-vimrc/9JDaLBi.gif" alt="Imgur"></p><hr><p>Unsynched transposition (cycle all regions, also in different lines)</p><p><img src="/en/2021/04/15/2021/coc-vimrc/UQOCxyf.gif" alt="Imgur"></p><hr><p>Shift regions left and right (M-S-&lt;&gt;)</p><p><img src="/en/2021/04/15/2021/coc-vimrc/Q7EF8YI.gif" alt="Imgur"></p><hr><p>Find words under cursor, add new words (patterns stack), navigate regions, skip them, add regions with regex.</p><p><img src="/en/2021/04/15/2021/coc-vimrc/zWtelNO.gif" alt="Imgur"></p><h4 id="undotree"><a href="#undotree" class="headerlink" title="undotree"></a><a href="https://github.com/mbbill/undotree">undotree</a></h4><p><img src="/en/2021/04/15/2021/coc-vimrc/undotree_new.png"></p><h5 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h5><table><thead><tr><th align="center">Shortcut</th><th align="center">Action</th></tr></thead><tbody><tr><td align="center"><code>:UndotreeToggle</code> OR <code>F5</code></td><td align="center">toggle the undo-tree panel.</td></tr><tr><td align="center"><code>:redo</code> OR <code>&lt;ctrl-r&gt;</code></td><td align="center">restore</td></tr><tr><td align="center"><code>[ number ]</code></td><td align="center">marks the most recent change</td></tr></tbody></table><ol><li>Use <code>:UndotreeToggle</code> to toggle the undo-tree panel. You may want to map this command to whatever hotkey by adding the following line to your vimrc, take <code>F5</code> for example.<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nnoremap &lt;F5&gt; :UndotreeToggle&lt;CR&gt;</span><br></pre></td></tr></table></figure></li><li>Markers<ul><li>Every change has a sequence number and it is displayed before timestamps.</li><li>The current state is marked as <code>&gt; number &lt;</code>.</li><li>The next state which will be restored by <code>:redo`:redo` or </code><ctrl-r><code>&lt;ctrl-r&gt;</code> is marked as <code>&#123; number &#125;</code>.</li><li>The <code>[ number ]</code> marks the most recent change.</li><li>The undo history is sorted by timestamps.</li><li>Saved changes are marked as <code>s</code> and the big <code>S</code> indicates the most recent saved change.</li></ul></li><li>Press <code>?</code> in undotree window for quick help.</li><li>Persistent undo<ul><li>Usually I would like to store the undo files in a seperate place like below.</li></ul></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if has(&quot;persistent_undo&quot;)</span><br><span class="line">   let target_path = expand(&#x27;~/.undodir&#x27;)</span><br><span class="line"></span><br><span class="line">    &quot; create the directory and any parent directories</span><br><span class="line">    &quot; if the location does not exist.</span><br><span class="line">    if !isdirectory(target_path)</span><br><span class="line">        call mkdir(target_path, &quot;p&quot;, 0700)</span><br><span class="line">    endif</span><br><span class="line"></span><br><span class="line">    let &amp;undodir=target_path</span><br><span class="line">    set undofile</span><br><span class="line">endif</span><br></pre></td></tr></table></figure><h4 id="vim-easy-align"><a href="#vim-easy-align" class="headerlink" title="vim-easy-align"></a><a href="https://github.com/junegunn/vim-easy-align">vim-easy-align</a></h4><p><strong>A simple, easy-to-use Vim alignment plugin.</strong></p><p><img src="/en/2021/04/15/2021/coc-vimrc/equals.gif"></p><p><code>ga</code> + <strong>symbol</strong> in normal or visual mode to align text based on <strong>symbol</strong></p><ul><li>with the following lines of text,</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apple   =red</span><br><span class="line">grass+=green</span><br><span class="line">sky-=   blue</span><br></pre></td></tr></table></figure><p>try these commands:</p><ul><li><code>vipga=</code><ul><li><code>v</code>isual-select <code>i</code>nner <code>p</code>aragraph</li><li>Start EasyAlign command (<code>ga</code>)</li><li>Align around <code>=</code></li></ul></li><li><code>gaip=</code><ul><li>Start EasyAlign command (<code>ga</code>) for <code>i</code>nner <code>p</code>aragraph</li><li>Align around <code>=</code></li></ul></li></ul><h5 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h5><h6 id="Using-predefined-alignment-rules"><a href="#Using-predefined-alignment-rules" class="headerlink" title="Using predefined alignment rules"></a>Using predefined alignment rules</h6><p>An <em>alignment rule</em> is a predefined set of options for common alignment tasks,<br>which is identified by a single character, such as <code>&lt;Space&gt;</code>, <code>=</code>, <code>:</code>, <code>.</code>,<br><code>|</code>, <code>&amp;</code>, <code>#</code>, and <code>,</code>.</p><h6 id=""><a href="#" class="headerlink" title="="></a><code>=</code></h6><p><img src="/en/2021/04/15/2021/coc-vimrc/equals.gif"></p><ul><li><code>=</code> Around the 1st occurrences</li><li><code>2=</code> Around the 2nd occurrences</li><li><code>*=</code> Around all occurrences</li><li><code>**=</code> Left/Right alternating alignment around all occurrences</li><li><code>&lt;Enter&gt;</code> Switching between left/right/center alignment modes</li></ul><h6 id="lt-Space-gt"><a href="#lt-Space-gt" class="headerlink" title="&lt;Space&gt;"></a><code>&lt;Space&gt;</code></h6><p><img src="/en/2021/04/15/2021/coc-vimrc/spaces.gif"></p><ul><li><code>&lt;Space&gt;</code> Around the 1st occurrences of whitespaces</li><li><code>2&lt;Space&gt;</code> Around the 2nd occurrences</li><li><code>-&lt;Space&gt;</code> Around the last occurrences</li><li><code>&lt;Enter&gt;&lt;Enter&gt;2&lt;Space&gt;</code> Center-alignment around the 2nd occurrences</li></ul><h6 id="-1"><a href="#-1" class="headerlink" title=","></a><code>,</code></h6><p><img src="/en/2021/04/15/2021/coc-vimrc/commas.gif"></p><ul><li>The predefined comma-rule places a comma right next to the preceding token<br>without margin (<code>&#123;&#39;stick_to_left&#39;: 1, &#39;left_margin&#39;: 0&#125;</code>)</li><li>You can change it with <code>&lt;Right&gt;</code> arrow</li></ul><h6 id="Using-regular-expression"><a href="#Using-regular-expression" class="headerlink" title="Using regular expression"></a>Using regular expression</h6><p><img src="/en/2021/04/15/2021/coc-vimrc/regex.gif"></p><p>You can use an arbitrary regular expression by</p><ul><li>pressing <code>&lt;Ctrl-X&gt;</code> in interactive mode</li><li>or using <code>:EasyAlign /REGEX/</code> command in visual mode or in normal mode with<br>a range (e.g. <code>:%</code>)</li></ul><p>Different ways to start</p><p><img src="/en/2021/04/15/2021/coc-vimrc/modes.gif"></p><p>This demo shows how you can start interactive mode with visual selection or use<br>non-interactive <code>:EasyAlign</code> command.</p><h6 id="Aligning-table-cells"><a href="#Aligning-table-cells" class="headerlink" title="Aligning table cells"></a>Aligning table cells</h6><p><img src="/en/2021/04/15/2021/coc-vimrc/tables.gif"></p><p>Check out various alignment options and “live interactive mode”.</p><h6 id="Syntax-aware-alignment"><a href="#Syntax-aware-alignment" class="headerlink" title="Syntax-aware alignment"></a>Syntax-aware alignment</h6><p><img src="/en/2021/04/15/2021/coc-vimrc/yaml.gif"></p><p>Delimiters in strings and comments are ignored by default.</p><h6 id="Using-blockwise-visual-mode"><a href="#Using-blockwise-visual-mode" class="headerlink" title="Using blockwise-visual mode"></a>Using blockwise-visual mode</h6><p><img src="/en/2021/04/15/2021/coc-vimrc/blockwise-visual.gif"></p><p><strong>A simple, easy-to-use Vim alignment plugin.</strong></p><p><img src="/en/2021/04/15/2021/coc-vimrc/equals.gif"></p><p><code>ga</code> + <strong>symbol</strong> in normal or visual mode to align text based on <strong>symbol</strong></p><ul><li>with the following lines of text,</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apple   =red</span><br><span class="line">grass+=green</span><br><span class="line">sky-=   blue</span><br></pre></td></tr></table></figure><p>try these commands:</p><ul><li><code>vipga=</code><ul><li><code>v</code>isual-select <code>i</code>nner <code>p</code>aragraph</li><li>Start EasyAlign command (<code>ga</code>)</li><li>Align around <code>=</code></li></ul></li><li><code>gaip=</code><ul><li>Start EasyAlign command (<code>ga</code>) for <code>i</code>nner <code>p</code>aragraph</li><li>Align around <code>=</code></li></ul></li></ul><h5 id="Demo-1"><a href="#Demo-1" class="headerlink" title="Demo"></a>Demo</h5><h6 id="Using-predefined-alignment-rules-1"><a href="#Using-predefined-alignment-rules-1" class="headerlink" title="Using predefined alignment rules"></a>Using predefined alignment rules</h6><p>An <em>alignment rule</em> is a predefined set of options for common alignment tasks,<br>which is identified by a single character, such as <code>&lt;Space&gt;</code>, <code>=</code>, <code>:</code>, <code>.</code>,<br><code>|</code>, <code>&amp;</code>, <code>#</code>, and <code>,</code>.</p><h6 id="-2"><a href="#-2" class="headerlink" title="="></a><code>=</code></h6><p><img src="/en/2021/04/15/2021/coc-vimrc/equals.gif"></p><ul><li><code>=</code> Around the 1st occurrences</li><li><code>2=</code> Around the 2nd occurrences</li><li><code>*=</code> Around all occurrences</li><li><code>**=</code> Left/Right alternating alignment around all occurrences</li><li><code>&lt;Enter&gt;</code> Switching between left/right/center alignment modes</li></ul><h6 id="lt-Space-gt-1"><a href="#lt-Space-gt-1" class="headerlink" title="&lt;Space&gt;"></a><code>&lt;Space&gt;</code></h6><p><img src="/en/2021/04/15/2021/coc-vimrc/spaces.gif"></p><ul><li><code>&lt;Space&gt;</code> Around the 1st occurrences of whitespaces</li><li><code>2&lt;Space&gt;</code> Around the 2nd occurrences</li><li><code>-&lt;Space&gt;</code> Around the last occurrences</li><li><code>&lt;Enter&gt;&lt;Enter&gt;2&lt;Space&gt;</code> Center-alignment around the 2nd occurrences</li></ul><h6 id="-3"><a href="#-3" class="headerlink" title=","></a><code>,</code></h6><p><img src="/en/2021/04/15/2021/coc-vimrc/commas.gif"></p><ul><li>The predefined comma-rule places a comma right next to the preceding token<br>without margin (<code>&#123;&#39;stick_to_left&#39;: 1, &#39;left_margin&#39;: 0&#125;</code>)</li><li>You can change it with <code>&lt;Right&gt;</code> arrow</li></ul><h6 id="Using-regular-expression-1"><a href="#Using-regular-expression-1" class="headerlink" title="Using regular expression"></a>Using regular expression</h6><p><img src="/en/2021/04/15/2021/coc-vimrc/regex.gif"></p><p>You can use an arbitrary regular expression by</p><ul><li>pressing <code>&lt;Ctrl-X&gt;</code> in interactive mode</li><li>or using <code>:EasyAlign /REGEX/</code> command in visual mode or in normal mode with<br>a range (e.g. <code>:%</code>)</li></ul><p>Different ways to start</p><p><img src="/en/2021/04/15/2021/coc-vimrc/modes.gif"></p><p>This demo shows how you can start interactive mode with visual selection or use<br>non-interactive <code>:EasyAlign</code> command.</p><h6 id="Aligning-table-cells-1"><a href="#Aligning-table-cells-1" class="headerlink" title="Aligning table cells"></a>Aligning table cells</h6><p><img src="/en/2021/04/15/2021/coc-vimrc/tables.gif"></p><p>Check out various alignment options and “live interactive mode”.</p><h6 id="Syntax-aware-alignment-1"><a href="#Syntax-aware-alignment-1" class="headerlink" title="Syntax-aware alignment"></a>Syntax-aware alignment</h6><p><img src="/en/2021/04/15/2021/coc-vimrc/yaml.gif"></p><p>Delimiters in strings and comments are ignored by default.</p><h6 id="Using-blockwise-visual-mode-1"><a href="#Using-blockwise-visual-mode-1" class="headerlink" title="Using blockwise-visual mode"></a>Using blockwise-visual mode</h6><p><img src="/en/2021/04/15/2021/coc-vimrc/blockwise-visual.gif"></p><p>You can limit the scope with blockwise-visual mode.</p><h4 id="calendar-vim"><a href="#calendar-vim" class="headerlink" title="calendar.vim"></a><a href="https://github.com/itchyny/calendar.vim">calendar.vim</a></h4><p><img src="/en/2021/04/15/2021/coc-vimrc/image.png" alt="calendar.vim"></p><p>Press E key to view the event list, and T key to view the task list.<br>Also, press ? key to view a quick help.</p><p><img src="/en/2021/04/15/2021/coc-vimrc/views.png" alt="calendar.vim"></p><h5 id="Basic-Usage"><a href="#Basic-Usage" class="headerlink" title="Basic Usage"></a>Basic Usage</h5><pre><code>:Calendar</code></pre><p><img src="/en/2021/04/15/2021/coc-vimrc/image0.png" alt="calendar.vim"></p><pre><code>:Calendar 2000 1 1</code></pre><p><img src="/en/2021/04/15/2021/coc-vimrc/image1.png" alt="calendar.vim"></p><pre><code>:Calendar -view=year</code></pre><p><img src="/en/2021/04/15/2021/coc-vimrc/image2.png" alt="calendar.vim"></p><pre><code>:Calendar -view=year -split=vertical -width=27</code></pre><p><img src="/en/2021/04/15/2021/coc-vimrc/image3.png" alt="calendar.vim"></p><pre><code>:Calendar -view=year -split=horizontal -position=below -height=12</code></pre><p><img src="/en/2021/04/15/2021/coc-vimrc/image4.png" alt="calendar.vim"></p><pre><code>:Calendar -first_day=monday</code></pre><p><img src="/en/2021/04/15/2021/coc-vimrc/image5.png" alt="calendar.vim"></p><pre><code>:Calendar -view=clock</code></pre><p><img src="/en/2021/04/15/2021/coc-vimrc/image6.png" alt="calendar.vim"></p><p>You can switch between views with &lt; and &gt; keys.</p><h4 id="vim-autoformat"><a href="#vim-autoformat" class="headerlink" title="vim-autoformat"></a><a href="https://github.com/Chiel92/vim-autoformat">vim-autoformat</a></h4><p>For convenience it is recommended that you assign a key for this, like so:</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">noremap</span> <span class="symbol">&lt;F3&gt;</span> :Autoformat<span class="symbol">&lt;CR&gt;</span></span><br></pre></td></tr></table></figure><p>Basic usage: <code>:Autoformat</code> OR <code>F3</code></p><h4 id="vim-gitgutter"><a href="#vim-gitgutter" class="headerlink" title="vim-gitgutter"></a><a href="https://github.com/airblade/vim-gitgutter">vim-gitgutter</a></h4><p>A Vim plugin which shows a git diff in the sign column. It shows which lines have been added, modified, or removed. You can also preview, stage, and undo individual hunks; and stage partial hunks. The plugin also provides a hunk text object.<br><img src="/en/screenshot.png?raw=true"></p><p>In the screenshot above you can see:</p><ul><li>Lines 183-184 are new.</li><li>Lines 186-187 have been modified.</li><li>The preview for the modified lines highlights changed regions within the line.</li></ul><h4 id="vim-surround"><a href="#vim-surround" class="headerlink" title="vim-surround"></a><a href="https://github.com/tpope/vim-surround">vim-surround</a></h4><p><img src="/en/2021/04/15/2021/coc-vimrc/surround_vim.gif"></p><h5 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h5><p>Press <code>cs&quot;&#39;</code> inside</p><pre><code>&quot;Hello world!&quot;</code></pre><p>to change it to</p><pre><code>&#39;Hello world!&#39;</code></pre><p>Now press <code>cs&#39;&lt;q&gt;</code> to change it to</p><pre><code>&lt;q&gt;Hello world!&lt;/q&gt;</code></pre><p>To go full circle, press <code>cst&quot;</code> to get</p><pre><code>&quot;Hello world!&quot;</code></pre><p>To remove the delimiters entirely, press <code>ds&quot;</code>.</p><pre><code>Hello world!</code></pre><p>Now with the cursor on “Hello”, press <code>ysiw]</code> (<code>iw</code> is a text object).</p><pre><code>[Hello] world!</code></pre><p>Let’s make that braces and add some space (use <code>&#125;</code> instead of <code>&#123;</code> for no<br>space): <code>cs]&#123;</code></p><pre><code>&#123; Hello &#125; world!</code></pre><p>Now wrap the entire line in parentheses with <code>yssb</code> or <code>yss)</code>.</p><pre><code>(&#123; Hello &#125; world!)</code></pre><p>Revert to the original text: <code>ds&#123;ds)</code></p><pre><code>Hello world!</code></pre><p>Emphasize hello: <code>ysiw&lt;em&gt;</code></p><pre><code>&lt;em&gt;Hello&lt;/em&gt; world!</code></pre><p>Finally, let’s try out visual mode. Press a capital V (for linewise<br>visual mode) followed by <code>S&lt;p class=&quot;important&quot;&gt;</code>.</p><pre><code>&lt;p class=&quot;important&quot;&gt;  &lt;em&gt;Hello&lt;/em&gt; world!&lt;/p&gt;</code></pre><h4 id="vim-markdown-toc"><a href="#vim-markdown-toc" class="headerlink" title="vim-markdown-toc"></a><a href="https://github.com/mzlogin/vim-markdown-toc">vim-markdown-toc</a></h4><p><img src="/en/2021/04/15/2021/coc-vimrc/english.gif" alt="gif"></p><ul><li><p>Generate table of contents for Markdown files.</p><p>Supported Markdown parsers:</p><ul><li><input checked="" disabled="" type="checkbox"> GFM (GitHub Flavored Markdown)</li><li><input checked="" disabled="" type="checkbox"> GitLab</li><li><input checked="" disabled="" type="checkbox"> Redcarpet</li></ul></li><li><p>Update existing table of contents.</p></li><li><p>Auto update existing table of contents on save.</p></li></ul><ol><li><p><code>:GenTocGFM</code></p><p> Generate table of contents in <a href="https://github.github.com/gfm/">GFM</a> link style.</p><p> This command is suitable for Markdown files in GitHub repositories, like <code>README.md</code>, and Markdown files for GitBook.</p></li><li><p><code>:GenTocRedcarpet</code></p><p> Generate table of contents in <a href="https://github.com/vmg/redcarpet">Redcarpet</a> link style.</p><p> This command is suitable for Jekyll or anywhere else use Redcarpet as its Markdown parser.</p></li><li><p><code>:GenTocGitLab</code></p><p> Generate table of contents in <a href="https://docs.gitlab.com/ee/user/markdown.html">GitLab</a> link style.</p><p> This command is suitable for GitLab repository and wiki.</p></li><li><p><code>:GenTocMarked</code></p><p> Generate table of contents for <a href="https://github.com/iamcco/markdown-preview.vim">iamcco/markdown-preview.vim</a> which use <a href="https://github.com/markedjs/marked">Marked</a> markdown parser.</p></li></ol><p>You can view <a href="http://mazhuang.org/2015/12/05/diff-between-gfm-and-redcarpet/">here</a> to know differences between <em>GFM</em> and <em>Redcarpet</em> style toc links.</p><h5 id="Update-existing-table-of-contents"><a href="#Update-existing-table-of-contents" class="headerlink" title="Update existing table of contents"></a>Update existing table of contents</h5><p>Generally you don’t need to do this manually, existing table of contents will auto update on save by default.</p><p>The <code>:UpdateToc</code> command, which is designed to update toc manually, can only work when <code>g:vmt_auto_update_on_save</code> turned off, and keep insert fence.</p><h5 id="Remove-table-of-contents"><a href="#Remove-table-of-contents" class="headerlink" title="Remove table of contents"></a>Remove table of contents</h5><p><code>:RemoveToc</code> command will do this for you, just remember keep insert fence option by default.</p><h4 id="vim-airline"><a href="#vim-airline" class="headerlink" title="vim-airline"></a><a href="https://github.com/vim-airline/vim-airline">vim-airline</a></h4><p>Lean &amp; mean status/tabline for vim that’s light as air.</p><p><img src="/en/2021/04/15/2021/coc-vimrc/demo.gif" alt="img"></p><p>When the plugin is correctly loaded, there will be a nice statusline at the<br>bottom of each vim window.</p><h5 id="Smarter-tab-line"><a href="#Smarter-tab-line" class="headerlink" title="Smarter tab line"></a>Smarter tab line</h5><p>Automatically displays all buffers when there’s only one tab open.</p><p><img src="/en/2021/04/15/2021/coc-vimrc/44c292a0-1495-11e3-9ce6-dcada3f1c536.gif" alt="tabline"></p><p>This is disabled by default; add the following to your vimrc to enable the extension:</p><pre><code>let g:airline#extensions#tabline#enabled = 1</code></pre><h5 id="vim-airline-themes"><a href="#vim-airline-themes" class="headerlink" title="vim-airline-themes"></a><a href="https://github.com/vim-airline/vim-airline-themes">vim-airline-themes</a></h5><h4 id="Indent-Guides"><a href="#Indent-Guides" class="headerlink" title="Indent Guides"></a><a href="https://github.com/nathanaelkane/vim-indent-guides">Indent Guides</a></h4><p>Indent Guides is a plugin for visually displaying indent levels in Vim.</p><img src="http://i.imgur.com/ONgoj.png" width="448" height="448" alt="" /><h5 id="Usage-1"><a href="#Usage-1" class="headerlink" title="Usage"></a>Usage</h5><p>The default mapping to toggle the plugin is <code>&lt;Leader&gt;ig</code>.</p><p>You can also use the following commands inside Vim:</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:IndentGuidesEnable</span><br><span class="line">:IndentGuidesDisable</span><br><span class="line">:IndentGuidesToggle</span><br></pre></td></tr></table></figure><p>If you would like to have indent guides enabled by default, you can add the following to your <code>~/.vimrc</code>:</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">g:indent_guides_enable_on_vim_startup</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="coc-nvim-extensions"><a href="#coc-nvim-extensions" class="headerlink" title="coc-nvim extensions"></a>coc-nvim extensions</h3><h4 id="Language-servers"><a href="#Language-servers" class="headerlink" title="Language servers"></a>Language servers</h4><h5 id="coc-clangd"><a href="#coc-clangd" class="headerlink" title="coc-clangd"></a><a href="https://github.com/clangd/coc-clangd">coc-clangd</a></h5><h5 id="coc-css"><a href="#coc-css" class="headerlink" title="coc-css"></a><a href="https://github.com/neoclide/coc-css">coc-css</a></h5><h5 id="coc-flutter"><a href="#coc-flutter" class="headerlink" title="coc-flutter"></a><a href="https://github.com/iamcco/coc-flutter">coc-flutter</a></h5><h5 id="coc-html"><a href="#coc-html" class="headerlink" title="coc-html"></a><a href="https://github.com/neoclide/coc-html">coc-html</a></h5><h5 id="coc-json"><a href="#coc-json" class="headerlink" title="coc-json"></a><a href="https://github.com/neoclide/coc-json">coc-json</a></h5><h5 id="coc-python"><a href="#coc-python" class="headerlink" title="coc-python"></a><a href="https://github.com/neoclide/coc-python">coc-python</a></h5><h5 id="coc-tsserver"><a href="#coc-tsserver" class="headerlink" title="coc-tsserver"></a><a href="https://github.com/neoclide/coc-tsserver">coc-tsserver</a></h5><h5 id="coc-vimlsp"><a href="#coc-vimlsp" class="headerlink" title="coc-vimlsp"></a><a href="https://github.com/iamcco/coc-vimlsp">coc-vimlsp</a></h5><h5 id="coc-yaml"><a href="#coc-yaml" class="headerlink" title="coc-yaml"></a><a href="https://github.com/neoclide/coc-yaml">coc-yaml</a></h5><h4 id="Other-coc-extensions"><a href="#Other-coc-extensions" class="headerlink" title="Other coc extensions"></a>Other coc extensions</h4><h5 id="coc-marketplace"><a href="#coc-marketplace" class="headerlink" title="coc-marketplace"></a><a href="https://github.com/fannheyward/coc-marketplace">coc-marketplace</a></h5><p><a href="https://github.com/neoclide/coc.nvim">coc.nvim</a>  extensions marketplace.</p><ul><li>search <code>keywords:coc.nvim</code> from npmjs.com, display extensions in <code>coc-lists</code></li><li>extension name starts with <code>√</code> means installed already, with an <code>uninstall</code> action</li><li>extension name starts with <code>x</code> means uninstalled, with an <code>install</code> action</li><li>extension name ends with <code>*</code> is published by @chemzqm, IMO, is official</li></ul><h6 id="Usage-2"><a href="#Usage-2" class="headerlink" title="Usage"></a>Usage</h6><ul><li><code>:CocList marketplace</code> list all available extensions</li><li><code>:CocList marketplace python</code> to search extension that name contains <code>python</code></li></ul><p><img src="/en/2021/04/15/2021/coc-vimrc/5cf885c18736a85017.png" alt="coc-marketplace"> </p><h5 id="coc-prettier"><a href="#coc-prettier" class="headerlink" title="coc-prettier"></a><a href="https://github.com/neoclide/coc-prettier">coc-prettier</a></h5><p>you can use <code>:Prettier</code> to format current buffer.<br>your can <code>&lt;leader&gt;f</code> for range format.</p><p>Prettier range format only support languageId including: <code>javascript</code>,<code>javascriptreact</code>, <code>typescript</code>, <code>typescriptreact</code>, <code>json</code> and <code>graphql</code>.</p><h6 id="Update-your-coc-settings-json-for-format-on-save"><a href="#Update-your-coc-settings-json-for-format-on-save" class="headerlink" title="Update your coc-settings.json for format on save"></a>Update your <code>coc-settings.json</code> for format on save</h6><p>Open settings file with:</p><pre><code>:CocConfig</code></pre><p>Add:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;coc.preferences.formatOnSaveFiletypes&quot;: [&quot;css&quot;, &quot;markdown&quot;],</span><br></pre></td></tr></table></figure><p>to setup the languages which you want to format on save.</p><h5 id="coc-snippets"><a href="#coc-snippets" class="headerlink" title="coc-snippets"></a><a href="https://github.com/neoclide/coc-snippets">coc-snippets</a></h5><table><thead><tr><th align="center">Shortcut</th><th align="center">Action</th></tr></thead><tbody><tr><td align="center"><code>Insert Mode</code>  <code>Ctrl</code> <code>l</code></td><td align="center">coc-snippets-expand<br>(trigger snippet expand)</td></tr><tr><td align="center"><code>Visual Mode</code>  <code>Ctrl</code> <code>j</code></td><td align="center">coc-snippets-select<br>(select text for visual placeholder of snippet)</td></tr><tr><td align="center"><code>Ctrl</code> <code>j</code></td><td align="center">coc_snippet_next<br>(jump to next placeholder, it’s default of coc.nvim)</td></tr><tr><td align="center"><code>Ctrl</code> <code>k</code></td><td align="center">coc_snippet_prev<br>(jump to previous placeholder, it’s default of coc.nvim)</td></tr><tr><td align="center"><code>xmap</code> <code>&lt;leader&gt;</code> <code>x</code></td><td align="center">coc-convert-snippet <br>(Use <leader>x for convert visual selected code to snippet)</td></tr><tr><td align="center"><code>imap</code> <code>&lt;C-j&gt;</code> <code>&lt;Plug&gt;</code></td><td align="center">coc-snippets-expand-jump <br>(Use <C-j> for both expand and jump (make expand higher priority.)</td></tr></tbody></table><p>Make <code>&lt;tab&gt;</code> used for trigger completion, completion confirm, snippet expand and jump like VSCode.</p><h6 id="vim-snippets"><a href="#vim-snippets" class="headerlink" title="vim-snippets"></a><a href="https://github.com/honza/vim-snippets">vim-snippets</a></h6><p>vim-snipmate default snippets (Previously snipmate-snippets)</p><p>This repository contains snippets files for various programming languages.</p><ul><li><code>snippets/*</code>: snippets using snipMate format</li><li><code>UltiSnips/*</code>: snippets using UltiSnips format</li></ul><h5 id="coc-explorer"><a href="#coc-explorer" class="headerlink" title="coc-explorer"></a><a href="https://github.com/weirongxu/coc-explorer">coc-explorer</a></h5><p>Explorer extension for <a href="https://github.com/neoclide/coc.nvim">coc.nvim</a></p><p><img src="/en/2021/04/15/2021/coc-vimrc/76720263-471be100-6777-11ea-82c1-614627097b02.png" alt="image"></p><ul><li>Open explorer <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;space&gt;e</span><br></pre></td></tr></table></figure></li></ul><h5 id="coc-translator"><a href="#coc-translator" class="headerlink" title="coc-translator"></a><a href="https://github.com/voldikss/coc-translator">coc-translator</a></h5><p>Translation extension for <a href="https://github.com/neoclide/coc.nvim">coc.nvim</a>.</p><p><img src="/en/2021/04/15/2021/coc-vimrc/103474126-b8e31b00-4ddb-11eb-916b-2e2d7b2b29e0.png"></p><table><thead><tr><th>Shortcut</th><th>Action</th></tr></thead><tbody><tr><td><code>&lt;Leader&gt;</code> <code>t</code></td><td>popup</td></tr><tr><td><code>&lt;Leader&gt;</code> <code>t</code></td><td>echo</td></tr><tr><td><code>&lt;Leader&gt;</code> <code>t</code></td><td>replace</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> coc-nvim </category>
          
          <category> vim </category>
          
          <category> document </category>
          
          <category> 文档 </category>
          
          <category> 代码编辑器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vim </tag>
            
            <tag> coc-nvim </tag>
            
            <tag> neovim </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
